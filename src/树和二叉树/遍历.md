# 144. 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
         vector<int> res;
         _preorder(root,res);
         return res;
    }

    void _preorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        res.push_back(root->val);
        _preorder(root->left,res);
        _preorder(root->right,res);
    }
};
```

非递归解法：

````
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                res.push_back(p->val);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                p =p->right;
            }
        }
        return res;
    }
};
````

# 94. 二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归解法：

```
class Solution {
public:
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> res;
		_inorder(root, res);
		return res;
	}

	void _inorder(TreeNode* root, vector<int> &res)
	{
		if (root == nullptr)
			return;
		_inorder(root->left, res);
		res.push_back(root->val);
		_inorder(root->right, res);
	}
};
```

非递归解法：

```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                res.push_back(p->val);
                p = p->right;
            }
        }        
        return res;        
    }

};
```

# 145. 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        _postorder(root,res);
        return res;
    }

    void _postorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        _postorder(root->left,res);   
        _postorder(root->right,res);   
        res.push_back(root->val);
    }
};
```

 非递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;   
        vector<int> res;
        TreeNode* p = root;
        TreeNode* prev = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                if(!p->right || p->right == prev)
                {
                    res.push_back(p->val);
                    st.pop();
                    prev = p;
                    p = nullptr;
                }
                else
                    p = p->right;
            }
        }
        return res;
    }
};
```

# 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        int curr = 1,next = 0;
        vector<int> level;   
        while(!q.empty())
        {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            curr --;

            if(node->left)
            {
                q.push(node->left);
                next ++;
            }
            if(node->right)
            {
                q.push(node->right);
                next ++;
            }

            if(curr == 0)
            {                
                res.push_back(level);
                level.clear();
                curr = next;
                next = 0;
            }
        }
        return res;
    }
};
```

简化的解法：

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        vector<int> level;
        while(!q.empty())
        {            
            size_t size = q.size();
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }   
            res.push_back(std::move(level));
        }
        return res;
    }
};
```

# 107. 二叉树的层次遍历 II

[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        vector<int> level;
        while(!q.empty())
        {            
            size_t size = q.size();
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }   
            res.push_back(std::move(level));
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

# 103. 二叉树的锯齿形层次遍历

[103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        vector<vector<int>> res;
        stack<TreeNode*> s1,s2;
        s1.push(root);
        bool l2r = true;
        vector<int> level;
        while(!s1.empty() || !s2.empty())
        {
            TreeNode* node = nullptr;
            if(l2r)
            {
                while(!s1.empty())
                {
                    node = s1.top();
                    s1.pop();
                    level.push_back(node->val);
                    if(node->left)
                        s2.push(node->left);
                    if(node->right)
                        s2.push(node->right);
                }
                l2r = false;
            }
            else
            {
                while(!s2.empty())
                {
                    node = s2.top();
                    s2.pop();
                    level.push_back(node->val);
                    if(node->right)
                        s1.push(node->right);
                    if(node->left)
                        s1.push(node->left);
                }   
                l2r = true;
            }
            res.push_back(move(level));                                   
        }
        return res;
    }
};
```

# 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<double> res;
        queue<TreeNode*>  q;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size();
            double sum = 0.0;
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                sum += node->val;
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
            res.push_back(sum / size);
        }
        return res;
    }
};
```

# 105. 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        if(n == 0) return nullptr;
        vector<int> Lin,Rin,Lpre,Rpre;
        TreeNode* root = new TreeNode(preorder[0]);
        int i = 0;
        for(;i < n;++i)
        {
            if(inorder[i] == preorder[0])
                break;
            Lin.push_back(inorder[i]);
        }
        for(int j = i+1;j < n;++j)
            Rin.push_back(inorder[j]);
        
        for(int j = 1;j < n;++j)
        {
            if(j <= Lin.size())
                Lpre.push_back(preorder[j]);
            else
                Rpre.push_back(preorder[j]);
        }

        root->left = buildTree(Lpre,Lin);
        root->right = buildTree(Rpre,Rin);
        return root;
    }
};
```

优化：

```
class Solution {
public:
    unordered_map<int,int> dict;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty())
            return nullptr;
        for(int i = 0;i < inorder.size();++i)
            dict[inorder[i]] = i;
        
        return build(preorder,0,preorder.size()-1,0);
    }

    TreeNode* build(vector<int>& preorder,int si,int ei,int sp)
    {
        if(si > ei)
            return nullptr;
        
        int val = preorder[sp],index = dict[val],leftLen = index - si -1;
        TreeNode* root = new TreeNode(val);
        root->left = build(preorder,si,index-1,sp+1);
        root->right = build(preorder,index+1,ei,sp+2+leftLen);
        return root;
    }
};
```

