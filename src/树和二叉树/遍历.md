# 144. 二叉树的前序遍历

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
         vector<int> res;
         _preorder(root,res);
         return res;
    }

    void _preorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        res.push_back(root->val);
        _preorder(root->left,res);
        _preorder(root->right,res);
    }
};
```

非递归解法：

````
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                res.push_back(p->val);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                p =p->right;
            }
        }
        return res;
    }
};
````

# 94. 二叉树的中序遍历

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归解法：

```
class Solution {
public:
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> res;
		_inorder(root, res);
		return res;
	}

	void _inorder(TreeNode* root, vector<int> &res)
	{
		if (root == nullptr)
			return;
		_inorder(root->left, res);
		res.push_back(root->val);
		_inorder(root->right, res);
	}
};
```

非递归解法：

```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                res.push_back(p->val);
                p = p->right;
            }
        }        
        return res;        
    }

};
```

# 145. 二叉树的后序遍历

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        _postorder(root,res);
        return res;
    }

    void _postorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        _postorder(root->left,res);   
        _postorder(root->right,res);   
        res.push_back(root->val);
    }
};
```

 非递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;   
        vector<int> res;
        TreeNode* p = root;
        TreeNode* prev = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                if(!p->right || p->right == prev)
                {
                    res.push_back(p->val);
                    st.pop();
                    prev = p;
                    p = nullptr;
                }
                else
                    p = p->right;
            }
        }
        return res;
    }
};
```

# 102. 二叉树的层序遍历

[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        int curr = 1,next = 0;
        vector<int> level;   
        while(!q.empty())
        {
            TreeNode* node = q.front();
            q.pop();
            level.push_back(node->val);
            curr --;

            if(node->left)
            {
                q.push(node->left);
                next ++;
            }
            if(node->right)
            {
                q.push(node->right);
                next ++;
            }

            if(curr == 0)
            {                
                res.push_back(level);
                level.clear();
                curr = next;
                next = 0;
            }
        }
        return res;
    }
};
```

简化的解法：

```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        vector<int> level;
        while(!q.empty())
        {            
            size_t size = q.size();
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }   
            res.push_back(std::move(level));
        }
        return res;
    }
};
```

# 107. 二叉树的层次遍历 II

[107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<vector<int>> res;
        queue<TreeNode*> q;
        q.push(root);
        vector<int> level;
        while(!q.empty())
        {            
            size_t size = q.size();
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                level.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }   
            res.push_back(std::move(level));
        }
        reverse(res.begin(),res.end());
        return res;
    }
};
```

# 103. 二叉树的锯齿形层次遍历

[103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

```
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        if(root == nullptr)
            return {};
        vector<vector<int>> res;
        stack<TreeNode*> s1,s2;
        s1.push(root);
        bool l2r = true;
        vector<int> level;
        while(!s1.empty() || !s2.empty())
        {
            TreeNode* node = nullptr;
            if(l2r)
            {
                while(!s1.empty())
                {
                    node = s1.top();
                    s1.pop();
                    level.push_back(node->val);
                    if(node->left)
                        s2.push(node->left);
                    if(node->right)
                        s2.push(node->right);
                }
                l2r = false;
            }
            else
            {
                while(!s2.empty())
                {
                    node = s2.top();
                    s2.pop();
                    level.push_back(node->val);
                    if(node->right)
                        s1.push(node->right);
                    if(node->left)
                        s1.push(node->left);
                }   
                l2r = true;
            }
            res.push_back(move(level));                                   
        }
        return res;
    }
};
```

# 637. 二叉树的层平均值

[637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        vector<double> res;
        queue<TreeNode*>  q;
        q.push(root);
        while(!q.empty())
        {
            int size = q.size();
            double sum = 0.0;
            for(int i = 0;i < size;++i)
            {
                TreeNode* node = q.front();
                q.pop();
                sum += node->val;
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
            res.push_back(sum / size);
        }
        return res;
    }
};
```

# 105. 从前序与中序遍历序列构造二叉树

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        if(n == 0) return nullptr;
        vector<int> Lin,Rin,Lpre,Rpre;
        TreeNode* root = new TreeNode(preorder[0]);
        int i = 0;
        for(;i < n;++i)
        {
            if(inorder[i] == preorder[0])
                break;
            Lin.push_back(inorder[i]);
        }
        for(int j = i+1;j < n;++j)
            Rin.push_back(inorder[j]);
        
        for(int j = 1;j < n;++j)
        {
            if(j <= Lin.size())
                Lpre.push_back(preorder[j]);
            else
                Rpre.push_back(preorder[j]);
        }

        root->left = buildTree(Lpre,Lin);
        root->right = buildTree(Rpre,Rin);
        return root;
    }
};
```

优化：

```
class Solution {
public:
    unordered_map<int,int> dict;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.empty())
            return nullptr;
        for(int i = 0;i < inorder.size();++i)
            dict[inorder[i]] = i;
        
        return build(preorder,0,preorder.size()-1,0);
    }

    TreeNode* build(vector<int>& preorder,int si,int ei,int sp)
    {
        if(si > ei)
            return nullptr;
        
        int val = preorder[sp],index = dict[val],leftLen = index - si -1;
        TreeNode* root = new TreeNode(val);
        root->left = build(preorder,si,index-1,sp+1);
        root->right = build(preorder,index+1,ei,sp+2+leftLen);
        return root;
    }
};
```

# 513. 找树左下角的值

[513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root == nullptr)
            return -1;
        vector<int> res;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty())
        {
            res.clear();
            int size = q.size();
            for(int i=0;i<size;++i)
            {
                auto node = q.front();
                q.pop();
                res.push_back(node->val);
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
        }
        return res.front();
    }
};
```

优化：

```
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if (nullptr == root)
            return -1;  

        int res = root->val;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty())
        {
            res = que.front()->val;
            int len = que.size();             
            for(int i=0;i<len;++i)
            {
                if (que.front()->left)
                    que.push(que.front()->left);
                if (que.front()->right)
                    que.push(que.front()->right);
                que.pop();
            }
        }
        return res;
    }
};
```

# 538. 把二叉搜索树转换为累加树

[538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

按照"右->中->左"的顺序进行遍历：

```
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr)
            return nullptr;
        
        stack<TreeNode*> stk;
        auto p = root;
        int sum = 0;
        while(true)
        {
            if(p)
            {
                stk.push(p);
                p = p->right;
            }
            else if(!stk.empty())
            {
                p = stk.top();
                stk.pop();
                p->val += sum;
                sum = p->val;
                p = p->left;
            }
            else
                break;
        }
        return root;
    }
};
```

先序遍历，再做累加：

```
class Solution {
public:
    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr)
            return nullptr;
        vector<TreeNode*> v;
        stack<TreeNode*> stk;
        auto p = root;
        while(!stk.empty() || p)
        {
            if(p)
            {
                stk.push(p);
                p = p->left;
            }
            else
            {
                p = stk.top();
                stk.pop();
                v.push_back(p);
                p = p->right;
            }
        }

        if(v.size() < 2)
            return root;
        auto back = v.back();
        for(size_t i = v.size()-2;i>0;i--)
        {
            v[i]->val += back->val;
            back = v[i];
        }
        v.front()->val += back->val;
        return root;
    }
};
```

# 199. 二叉树的右视图

[199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
		vector<int>  res;
		if(root == nullptr)
			return res;
		queue<TreeNode*> q;
		q.push(root);
		while(!q.empty())
		{
			int size = q.size();
			for(int i = 0;i < size;++i)
			{
				auto t = q.front();
				q.pop();
				if(t->left)
					q.push(t->left);
				if(t->right)
					q.push(t->right);
				if(i == size -1)
					res.push_back(t->val);
			}
		}
		return res;
    }
};
```









[671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

[1038. 从二叉搜索树到更大和树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/)

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

[897. 递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

[530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

[889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

[236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

[897. 递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

[450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)