# 二叉树的前序遍历

[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
         vector<int> res;
         _preorder(root,res);
         return res;
    }

    void _preorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        res.push_back(root->val);
        _preorder(root->left,res);
        _preorder(root->right,res);
    }
};
```

非递归解法：

````
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                res.push_back(p->val);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                p =p->right;
            }
        }
        return res;
    }
};
````

# 二叉树的中序遍历

[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

递归解法：

```
class Solution {
public:
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> res;
		_inorder(root, res);
		return res;
	}

	void _inorder(TreeNode* root, vector<int> &res)
	{
		if (root == nullptr)
			return;
		_inorder(root->left, res);
		res.push_back(root->val);
		_inorder(root->right, res);
	}
};
```

非递归解法：

```
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        
        stack<TreeNode*> st;
        vector<int> res;
        TreeNode* p = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                st.pop();
                res.push_back(p->val);
                p = p->right;
            }
        }        
        return res;        
    }

};
```

# 二叉树的后序遍历

[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        _postorder(root,res);
        return res;
    }

    void _postorder(TreeNode* root,vector<int>& res)
    {
        if(root == nullptr)
            return;
        _postorder(root->left,res);   
        _postorder(root->right,res);   
        res.push_back(root->val);
    }
};
```

 非递归解法：

```
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        if(root == nullptr)
            return {};
        stack<TreeNode*> st;   
        vector<int> res;
        TreeNode* p = root;
        TreeNode* prev = root;
        while(!st.empty() || p)
        {
            if(p)
            {
                st.push(p);
                p = p->left;
            }
            else{
                p = st.top();
                if(!p->right || p->right == prev)
                {
                    res.push_back(p->val);
                    st.pop();
                    prev = p;
                    p = nullptr;
                }
                else
                    p = p->right;
            }
        }
        return res;
    }
};
```

# 二叉树的层序遍历

[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)





















