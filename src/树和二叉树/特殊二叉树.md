# 101. 对称二叉树

[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

递归：

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr)
            return true;
        return  _Symmetric(root->left,root->right);
    }

    bool _Symmetric(TreeNode* left,TreeNode* right)
    {
        if(left == nullptr && right == nullptr)
            return true;
        if(left == nullptr || right == nullptr)
            return false;
        if(left->val != right->val)
            return false;
        return _Symmetric(left->left,right->right) && _Symmetric(left->right,right->left);
    }
};
```

非递归：

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr)
            return true;
        queue<TreeNode*> q;
        q.push(root->left);
        q.push(root->right);
        while(!q.empty())
        {
            TreeNode* L = q.front();
            q.pop();
            TreeNode* R = q.front();
            q.pop();
            if(L == nullptr && R == nullptr)
                continue;
            if(L == nullptr || R == nullptr || (L->val != R->val))
                return false;
            q.push(L->left);
            q.push(R->right);
            q.push(L->right);
            q.push(R->left);
        }
        return true;
    }
};
```

# 669. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == nullptr)
            return nullptr;
        
        if(root->val > high)
            return trimBST(root->left,low,high);    //只处理左子树，相当于剪掉了root及其右子树
        if(root->val < low)
            return trimBST(root->right,low,high);   //只处理右子树，相当于剪掉了root及其左子树
        
        root->left = trimBST(root->left,low,high);
        root->right = trimBST(root->right,low,high);
        return root;
    }
};
```

# 208. 实现 Trie (前缀树)

[208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

```
class Trie {

    class TrieNode
    {
    public:
        TrieNode* _child[26];
        bool _ending;
    public:
        TrieNode():_ending(false)
        {
            for(int i=0;i<26;i++) 
                _child[i] = nullptr;
        }
    };

    TrieNode* _root;
public:
    /** Initialize your data structure here. */
    Trie() {
        _root = new TrieNode();
    }
    
    /** Inserts a word into the trie. */
    void insert(string word) {
        TrieNode* curr = _root;
        for(auto chr : word)
        {
            int idx = chr-'a';
            if(curr->_child[idx]==nullptr) 
                curr->_child[idx]=new TrieNode();
            curr = curr->_child[idx];
        }
        curr->_ending=true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        TrieNode* curr = _root;
        for(auto chr : word)
        {
            int idx = chr-'a';
            if(curr->_child[idx] == nullptr) 
                return false;
            curr = curr->_child[idx];
        }
        return curr->_ending;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        TrieNode* curr = _root;
        for(auto chr:prefix)
        {
            int idx = chr-'a';
            if(curr->_child[idx] == nullptr) 
                return false;
            curr = curr->_child[idx];
        }
        return true;
    }
};
```

