# 669. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == nullptr)
            return nullptr;
        
        if(root->val > high)
            return trimBST(root->left,low,high);    //只处理左子树，相当于剪掉了root及其右子树
        if(root->val < low)
            return trimBST(root->right,low,high);   //只处理右子树，相当于剪掉了root及其左子树
        
        root->left = trimBST(root->left,low,high);
        root->right = trimBST(root->right,low,high);
        return root;
    }
};
```

# 230. 二叉搜索树中第K小的元素

[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

中序遍历：

```
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(root == nullptr)
            return -1;
		vector<int> res;
		inorder(root,res);
        return res.size() >=k ?  res[k-1] : -1;		 
    }
	
	void inorder(TreeNode* root,vector<int>& res)
	{
		if(root == nullptr)
			return;
		inorder(root->left,res);
		res.push_back(root->val);
		inorder(root->right,res);
	}
};
```

二分法：

```
class Solution {
public:
    int numofNodes(struct TreeNode* root)
    {
        if(root == nullptr) 
            return 0;
        return 1 + numofNodes(root->left) + numofNodes(root->right);
    }

    int kthSmallest(struct TreeNode* root, int k){
        int cnt = numofNodes(root->left);
        if(k <= cnt) 
            return kthSmallest(root->left,k);
        else if(k > cnt+1) 
            return kthSmallest(root->right,k-cnt-1);
        return root->val; // k == cnt+ 1
    }
};
```

# 700. 二叉搜索树中的搜索

[700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

递归：

```
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
		if(root == nullptr)
			return nullptr;
		if(root->val == val)
			return root;
		else if(root->val > val)
			return searchBST(root->left,val);
		else
			return searchBST(root->right,val);
    }
};
```

迭代：

```
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while(root && root->val !=  val)
            root->val > val ? root = root->left : root = root->right;
        return root;
    }
};
```

栈迭代：

```
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        stack<TreeNode*> stk;
        if(root)
            stk.push(root);
        while(!stk.empty())
        {
            auto t = stk.top();
            stk.pop();
            if(t->val == val)
                return t;
            else if(t->val > val && t->left)
                stk.push(t->left);
            else if(t->val < val && t->right)  
                stk.push(t->right);
        }
        return nullptr;
    }
};
```

# 897. 递增顺序查找树

[897. 递增顺序查找树](https://leetcode-cn.com/problems/increasing-order-search-tree/)

```
class Solution {
public:
	vector<TreeNode*> inorderV;
	void inorder(TreeNode* root)
	{
		if(root == nullptr)
			return;
		
		inorder(root->left);
		inorderV.push_back(root);
		inorder(root->right);
	}
	
    TreeNode* increasingBST(TreeNode* root) {
        if(root == nullptr)
			return nullptr;
		inorder(root);	
		for(int i=0;i<inorderV.size()-1;++i)
		{
			inorderV[i]->left = nullptr;
			inorderV[i]->right = inorderV[i+1];
		}
		inorderV.back()->left = nullptr;
		inorderV.back()->right = nullptr;
        return inorderV.front();
    }
};
```

# 235. 二叉搜索树的最近公共祖先

[235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || p == nullptr || q == nullptr)
			return nullptr;
		if(root->val > p->val && root->val > q->val)
			return lowestCommonAncestor(root->left,p,q);
		else if(root->val < p->val && root->val < q->val)
			return lowestCommonAncestor(root->right,p,q);
		return root;
    }
};
```

