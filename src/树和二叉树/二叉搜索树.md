# 669. 修剪二叉搜索树

[669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == nullptr)
            return nullptr;
        
        if(root->val > high)
            return trimBST(root->left,low,high);    //只处理左子树，相当于剪掉了root及其右子树
        if(root->val < low)
            return trimBST(root->right,low,high);   //只处理右子树，相当于剪掉了root及其左子树
        
        root->left = trimBST(root->left,low,high);
        root->right = trimBST(root->right,low,high);
        return root;
    }
};
```

# 230. 二叉搜索树中第K小的元素

[230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

中序遍历：

```
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        if(root == nullptr)
            return -1;
		vector<int> res;
		inorder(root,res);
        return res.size() >=k ?  res[k-1] : -1;		 
    }
	
	void inorder(TreeNode* root,vector<int>& res)
	{
		if(root == nullptr)
			return;
		inorder(root->left,res);
		res.push_back(root->val);
		inorder(root->right,res);
	}
};
```

二分法：

```
class Solution {
public:
    int numofNodes(struct TreeNode* root)
    {
        if(root == nullptr) 
            return 0;
        return 1 + numofNodes(root->left) + numofNodes(root->right);
    }

    int kthSmallest(struct TreeNode* root, int k){
        int cnt = numofNodes(root->left);
        if(k <= cnt) 
            return kthSmallest(root->left,k);
        else if(k > cnt+1) 
            return kthSmallest(root->right,k-cnt-1);
        return root->val; // k == cnt+ 1
    }
};
```

