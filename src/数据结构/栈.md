# 用栈实现队列

[用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```
class MyQueue {
public:
    stack<int> _SIn,_SOut;
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        _SIn.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(_SOut.empty())
        {
            while(!_SIn.empty())
            {
                _SOut.push(_SIn.top());
                _SIn.pop();
            }
        }

        int x = _SOut.top();
        _SOut.pop();
        return x; 
    }
    
    /** Get the front element. */
    int peek() {
        int x = this->pop();
        _SOut.push(x);
        return x;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return _SIn.empty() && _SOut.empty();
    }
};
```

# 用队列实现栈

[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```
class MyStack {
public:
    queue<int> _QIn,_QOut;
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        _QIn.push(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        while(_QIn.size() > 1)
        {
             _QOut.push(_QIn.front());
             _QIn.pop();
        }           
        int x = _QIn.front();
        //@ 复制回去并清空_QOut
        _QIn = _QOut;  
        while(!_QOut.empty())
            _QOut.pop();
        return x;
    }
    
    /** Get the top element. */
    int top() {
        return _QIn.back();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return _QIn.empty();
    }
};
```

# 有效的括号

[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```
class Solution {
public:
    bool isValid(string s) {
        stack<char> stk;
        for(auto const c : s)
        {
            if(c == '(' || c =='[' || c == '{')
                stk.push(c);
            else if(c == ')' || c ==']' || c == '}')
            {
                if(stk.empty())
                    return false;
                    
                if(c == ')')
                {
                    if(stk.top() == '(')
                        stk.pop();
                    else
                        return false;
                }
                else if(c == ']')
                {
                    if(stk.top() == '[')
                        stk.pop();
                    else
                        return false;
                }
                else
                {
                    if(stk.top() == '{')
                        stk.pop();
                    else
                        return false;
                }
            }
            else
                return false;
        }
        return stk.empty();
    }
};
```

# 包含min函数的栈

[包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)