# 347. 前 K 个高频元素

[347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

方法1：

```
class Solution {
public:
       vector<int> topKFrequent(vector<int>& nums, int k) {		
		map<int,int> dict;
		for(const auto n : nums)
			dict[n]++;
		
		typedef pair<int,int>  Data;
		vector<Data> vec(dict.begin(),dict.end());
		sort(vec.begin(),vec.end(),[](const Data& d1,const Data& d2){
			return d1.second > d2.second;
		});
		vector<int> res;
		for(int i = 0; i < k;++i)
			res.push_back(vec[i].first);
        return res;
    }
};
```

方法2：

```
class Solution {
public:
	typedef pair<int, int> Data;
	struct Comp
	{
		bool operator()(const Data& lhs, const Data& rhs)
		{
			return lhs.second > rhs.second;
		}		
	};

	vector<int> topKFrequent(vector<int>& nums, int k) {
		unordered_map<int, int> dict;
		for (const auto n : nums)
			dict[n] ++;
		priority_queue<Data,vector<Data>, Comp> pq;
		for (auto it = dict.begin(); it != dict.end(); ++it)
		{
			pq.push(*it);
			if (pq.size() > k)
				pq.pop();
		}

		vector<int> res;
        while(!pq.empty())
		{
			res.push_back(pq.top().first);
			pq.pop();
		}          
        return res;
	}
};
```

# 451. 根据字符出现频率排序

[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

```
class Solution {
public:
	  string frequencySort(string s) {
		unordered_map<char, int> dict;
		for (auto const c : s)
			dict[c]++;
		typedef pair<char, int> Data;
		vector<Data> vec(dict.begin(), dict.end());
		sort(vec.begin(), vec.end(), [](const Data& d1, const Data& d2)
		{return d1.second > d2.second; });
		string res;
		for (const auto v : vec)
		{
			string str(v.second, v.first);	//@ string(n,char)
			res += str;
		}
		return res;
	}
};
```

# 75. 颜色分类

[75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

```
class Solution {
  public:
  void sortColors(vector<int>& nums) {
    int curr = 0,left = 0,right = nums.size() - 1;
    while (curr <= right) 
	{
      if (nums[curr] == 0)
        swap(nums[curr++], nums[left++]);
      else if (nums[curr] == 2)
        swap(nums[curr], nums[right--]);  //@ 此处不能直接curr++，因为从后面换过来的数据，是什么不确定
      else 
		  curr++;
    }
  }
};
```

