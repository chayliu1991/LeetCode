# 快速排序

- 选择一个基准元素，将原数组划分为两半，然后在两半元素上分别再次进行排序，直到整个序列有序：

```
void quick_sort(vector<int>& nums, int left, int right)
{
	if (left < right)
	{
		int i = left, j = right, pivot = nums[left];
		while (i < j)
		{
			while (i < j && nums[j] >= pivot)
				j--;
			if (i < j)
				nums[i++] = nums[j];

			while (i < j && nums[i] < pivot)
				i++;
			if (i < j)
				nums[j--] = nums[i];

			nums[i] = pivot;  //@ pivot 在正确的位置上，并且将数组划分两半
			quick_sort(nums, left, i - 1);
			quick_sort(nums, i + 1, right);
		}
	}
}
```

# 冒泡排序

- 循环 n 次，每次把当前最大的值交换到尾后，可以设置 flag ，提前结束：

```
void bubble_sort(vector<int>& nums)
{
	int n = nums.size();
	
	//@ 遍历的次数
	for (int i = 0; i < n; ++i)
	{
		bool flag = false;  //@ 来个标记	
		for (int j = 1; j < n - i; ++j)
		{
			if (nums[j - 1] > nums[j])
			{
				//@ 把当前最大的值往后换
				swap(nums[j - 1], nums[j]);
				flag = true;
			}				
		}
		
		//@ 提前结束	
		if (flag == false)
			return;
	}
}
```











































































































