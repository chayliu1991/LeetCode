# 快速排序

- 选择一个基准元素，将原数组划分为两半，然后在两半元素上分别再次进行排序，直到整个序列有序：

```
void quick_sort(vector<int>& nums, int left, int right)
{
	if (left < right)
	{
		int i = left, j = right, pivot = nums[left];
		while (i < j)
		{
			while (i < j && nums[j] >= pivot)
				j--;
			if (i < j)
				nums[i++] = nums[j];

			while (i < j && nums[i] < pivot)
				i++;
			if (i < j)
				nums[j--] = nums[i];

			nums[i] = pivot;  //@ pivot 在正确的位置上，并且将数组划分两半
			quick_sort(nums, left, i - 1);
			quick_sort(nums, i + 1, right);
		}
	}
}
```

# 冒泡排序

- 循环 n 次，每次把当前最大的值交换到尾后，可以设置 flag ，提前结束：

```
void bubble_sort(vector<int>& nums)
{
	int n = nums.size();
	
	//@ 遍历的次数
	for (int i = 0; i < n; ++i)
	{
		bool flag = false;  //@ 来个标记	
		for (int j = 1; j < n - i; ++j)
		{
			if (nums[j - 1] > nums[j])
			{
				//@ 把当前最大的值往后换
				swap(nums[j - 1], nums[j]);
				flag = true;
			}				
		}
		
		//@ 提前结束	
		if (flag == false)
			return;
	}
}
```

# 选择排序

```
void select_sort(vector<int>& nums)
{
	int n = nums.size();
	 
	for (int i = 0; i < n - 1; ++i)	//@ 循环 n - 1次
	{
		int minIndex = i;  //@ 初始化最小值的索引
		for (int j = i + 1; j < n; ++j)
		{
			if (nums[j] < nums[minIndex])
				minIndex = j;		
		}	

		if(minIndex != i) //@ 最小值索引改变了，才交换一次
			swap(nums[i], nums[minIndex]);
	}
}
```



# 插入排序

```
void insert_sort(vector<int>& nums)
{
	int n = nums.size();
	for (int i = 1; i < n; ++i)
	{
		int j = i;
		while (j > 0 && nums[j] < nums[j - 1])
		{
			swap(nums[j], nums[j - 1]);
			j--;
		}
	}
}
```

# 归并排序

```
void merge(vector<int>& nums, int low, int mid, int high)
{
	int i = low, j = mid + 1, k = 0;
	vector<int> temp(high - low + 1, 0);
	while (i <= mid && j <= high)
	{
		if (nums[i] <= nums[j])
			temp[k++] = nums[i++];
		else
			temp[k++] = nums[j++];
	}

	while (i <= mid)
		temp[k++] = nums[i++];
	while (j <= high)
		temp[k++] = nums[j++];
	for (i = low, k = 0; i <= high; i++, k++)
		nums[i] = temp[k];
}

void merge_sort(vector<int>& nums, int low, int high)
{
	if (low >= high)
		return;
	int mid = low + ((high - low) >> 1);
	merge_sort(nums, low, mid);
	merge_sort(nums, mid + 1, high);
	merge(nums, low, mid, high);
}
```

# 希尔排序

```
//@ 移动法
void shell_sort(vector<int> &nums) {
	int n = nums.size();
	for (int gap = n / 2; gap > 0; gap /= 2)
	{
		for (int i = gap; i < n; i++)
		{
			int tmp = nums[i], j = i - gap;
			for (; j >= 0; j -= gap)
			{
				if (nums[j] > tmp)
					nums[j + gap] = nums[j];
				else
					break;
			}
			nums[j + gap] = tmp;
		}
	}
}

//@ 交换法
void shell_sort(vector<int> &nums)
{
	int n = nums.size();
	for (int gap = n / 2; gap > 0; gap /= 2)
	{
		for (int i = gap; i < n; i++) 
		{
			for (int j = i - gap; j >= 0; j -= gap)
			{
				if (nums[j] > nums[j + gap])
					swap(nums[j + gap], nums[j]);
				else
					break;
			}
		}
	}
}
```

# 堆排序

```
void adjust(vector<int> &nums, int index, int size)
{
	//@ index 是根节点
	while (index * 2 + 1 < size) //是否已经是叶子节点
	{

		int j = index * 2 + 1;    //@ j 是左孩子节点,j+1是右孩子节点     
		if (j < size && j + 1 < size && nums[j + 1] > nums[j])
			j++;
		if (nums[index] >= nums[j])
			break;
		swap(nums[index], nums[j]);
		index = j;
	}
}
//@ 给定一个数组，建立大根堆
void heapify(vector<int> &nums)
{
	int size = nums.size();
	//@ size/2 -1 是最后一个非叶子节点，它以下都是叶子节点，不用下沉了
	for (int i = size / 2 - 1; i >= 0; i--)
		adjust(nums, i, size);
}
void heap_sort(vector<int> &nums) {
	int n = nums.size();
	heapify(nums);//@ 建立大根堆
	while (n > 1)
	{
		swap(nums[0], nums[--n]);	//@ 选择最大元素（根）
		adjust(nums, 0, n);	//@ 修复堆
	}
}
```

# 基数排序

```
void sort(vector<int>& nums, int exp)
{
	int n = nums.size();
	vector<int> range(10, 0), tmpVec(n, 0);

	for (const auto n : nums)
		range[(n / exp) % 10]++;

	for (int i = 1; i < range.size(); ++i)
		range[i] += range[i - 1];//@ 统计本应该出现的位置

	for (int i = n - 1; i >= 0; --i)
	{
		tmpVec[range[(nums[i] / exp) % 10] - 1] = nums[i];
		range[(nums[i] / exp) % 10]--;
	}
	nums = tmpVec;
}

void radix_sort(vector<int>& nums)
{
	int n = nums.size();
	int maxi = INT_MIN;
	for (const auto n : nums)
		maxi = max(maxi, n);

	//@ 提取每一位并进行比较，位数不足的高位补0
	for (int exp = 1; maxi / exp > 0; exp *= 10)
		sort(nums, exp);
}
```

# 八大排序算法总结









































































































