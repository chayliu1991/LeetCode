# 摆动序列

[摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

这里使用了状态机的方法：

![](../../img/state_machine.png)

```
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        if(n < 2) return n;

        enum STATE {BEGIN = 0,UP,DOWN};
        STATE state = BEGIN;
        int max_len = 1;
        for(int i=1;i<n;i++)
        {
            switch(state)
            {
                case BEGIN:
                    if(nums[i-1] < nums[i])
                    {
                        state = UP;
                        max_len++;
                    }
                    else if(nums[i-1] > nums[i])
                    {
                        state = DOWN;
                        max_len++;
                    }
                    break;
                case UP:
                    if(nums[i-1] > nums[i])
                    {
                        state = DOWN;
                        max_len++;
                    }
                    break;
                case DOWN:
                if(nums[i-1] < nums[i])
                {
                    state = UP;
                    max_len++;
                }
                break;
            }
        } 
        return max_len;
    }
};
```

# 柠檬水找零

[柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)

```
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int fives = 0,tens = 0;
        for(const auto bill : bills)
        {
            if(bill == 5)
                fives++;
            else if(bill == 10)
            {
                if(fives > 0)
                    fives--,tens++;   
                else    
                    return false;
            }
            else
            {
                if(fives > 0 && tens > 0)
                    fives--,tens--;
                else if(fives >= 3)
                    fives -= 3;
                else
                    return false;
            }
        }
        return true;
    }
};
```

# 根据身高重建队列

[根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

- 将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。
- 按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。
- 直到完成为止。

```
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort(people.begin(),people.end(),[](const vector<int>& lhs,const vector<int>& rhs){
            return lhs[0] > rhs[0] || (lhs[0] == rhs[0] && lhs[1] < rhs[1]);
        });

        vector<vector<int>> res;
        for(auto const p : people)
        {
            res.insert(res.begin() + p[1],p);
        }
        return res;
    }
};
```

# 加油站

[加油站](https://leetcode-cn.com/problems/gas-station/)





