# 461. 汉明距离

[461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

方法一：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y; //@ 相同的位为0，不同的位为1
        while(n > 0)
        {
            if(n & 0x01)
                res++;
            n >>= 1; //@ 左移一位
        }
        return res;
    }
};
```

方法二：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y; //@ 相同的位为0，不同的位为1
        while(n)
        {
            res ++;
            //@ 统计一个数字的二进制位有多少个1
            n &= (n-1);
        }
        return res;
    }
};
```

方法三：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
       //@ 使用bitset
       return bitset<32>(x ^ y).count();
    }
};
```

# 190. 颠倒二进制位

[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

```
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for(int i = 0;i < 32; ++i)
        {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
};
```

# 136. 只出现一次的数字

[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(const auto x : nums)
            res ^= x;
        return res;
    }
};
```

# 342. 4的幂

[342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

```
class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num && num % 4 == 0)
            num /= 4;
        return num == 1;
    }
};
```

 4 的幂次方的数的二进制表示 1 的位置都是在奇数位。符合这两个条件的二进制数是：

```
1010101010101010101010101010101 //@ 0x55555555
```

并且这个数应该首先满足能被2整除：

```
class Solution {
public:
    bool isPowerOfFour(int num) {
        if(num <= 0)
            return false;
        
        //@ 不能被2整除
        if(num & num - 1)
            return false;
        if((num & 0x55555555) == num)
            return true;
        return false;
    }
};
```

# 318. 最大单词长度乘积

[318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

```
class Solution {
public:
    int str2int(const string& s) {
        int res = 0;
        for (auto c : s)
            res |= 1 << (c - 'a');
        return res;
    }
    int maxProduct(vector<string>& words) {
        int N = words.size();
        vector<int> v(N, 0);
        for (int i = 0; i < N; ++i)
            v[i] = str2int(words[i]);
        int res = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < i; ++j) {
                if ((v[i] & v[j]) == 0 && words[i].size() * words[j].size() > res)
                    res = words[i].size() * words[j].size();
            }
        }
        return res;
    }
};
```

