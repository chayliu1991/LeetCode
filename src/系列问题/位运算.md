# 461. 汉明距离

[461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

方法一：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y; //@ 相同的位为0，不同的位为1
        while(n > 0)
        {
            if(n & 0x01)
                res++;
            n >>= 1; //@ 左移一位
        }
        return res;
    }
};
```

方法二：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y; //@ 相同的位为0，不同的位为1
        while(n)
        {
            res ++;
            //@ 统计一个数字的二进制位有多少个1
            n &= (n-1);
        }
        return res;
    }
};
```

方法三：

```
class Solution {
public:
    int hammingDistance(int x, int y) {
       //@ 使用bitset
       return bitset<32>(x ^ y).count();
    }
};
```

# 190. 颠倒二进制位

[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

```
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for(int i = 0;i < 32; ++i)
        {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
};
```

# 136. 只出现一次的数字

[136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(const auto x : nums)
            res ^= x;
        return res;
    }
};
```

# 342. 4的幂

[342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

```
class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num && num % 4 == 0)
            num /= 4;
        return num == 1;
    }
};
```

