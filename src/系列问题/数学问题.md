# 简单数学知识

辗转相除法：

```
int gcd(int a, int b)
{
	return b == 0 ? a : gcd(b, a % b);
}
```

最小公倍数：

```
int lcm(int a, int b)
{
	return  (a * b) / gcd(a, b);
}
```

质数：又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。 

# 204. 计数质数

[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

除了2，其它偶数一定不是质数，只需要查看小于n的奇数中有多少是质数：

```
class Solution {
public:
    int countPrimes(int n) {
        int result = 0;
        vector<bool> prime(n,false);
        if(n > 2)
            result ++; //@ 如果大于2，则一定包含2这个质数
        for(int i = 3;i < n; i += 2) //@ 从 3 开始遍历，且只遍历奇数
        {
            if(prime[i] == false)
            {
                for(int j = 3;i * j < n;j += 2)
                    prime[i * j] = true; //@ 将当前质数的奇数倍都设置成非质数标记 true
                result ++;  //@ 质数个数 + 1
            }
        }
        return result;
    }
};
```

# 504. 七进制数

[504. 七进制数](https://leetcode-cn.com/problems/base-7/)

递归：

```
class Solution {
public:
    string convertToBase7(int num) {
        if(num < 0)
            return  "-" + convertToBase7(-num);
        if(num < 7)
            return to_string(num);
        return convertToBase7(num / 7) + to_string(num % 7);
    } 
};
```

非递归：

```
class Solution {
public:
    string convertToBase7(int num) {
        string res;
        int negative = num < 0;
        if(negative)
            num = -num;
        while(num / 7 != 0)
        {
            res = char(num % 7 + '0') + res;
            num /= 7;
        }
        res = char(num + '0') + res;
        return negative ? "-" + res : res;
    }
};
```

# 172. 阶乘后的零

[172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

每个尾部的 0 由 `2 * 5 = 10` 而来，因此可以把每一个元素拆分成质数相乘，统计有多少个 2 和 5。质因子 2 的数量远多于质因子 5 的数量，因此，可以统计阶乘结果里有多少个质因子 5：

```
class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        while(n >= 5)
        {
            count += n /5;
            n /= 5;
        }
        return count;
    }
};
```

递归：

```
class Solution {
public:
    int trailingZeroes(int n) {
        return n >= 5 ? n / 5 + trailingZeroes(n / 5) : 0; 
    }
};
```

# 415. 字符串相加

[415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

```
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i = num1.size() - 1,j = num2.size() - 1;
        int add = 0;
        string res;
        while(i >= 0 || j >= 0 || add != 0)
        {
            int x = i >= 0 ? num1[i] - '0' : 0;
            int y = j >= 0 ? num2[j] - '0' : 0;
            int result = x + y + add;
            res.push_back('0' + result % 10);
            add = result / 10;
            i -= 1;
            j -= 1;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

# 326. 3的幂

[326. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

```
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n <= 0)
            return false;
        double d = log10(n) / log10(3);  //@ 换底
        return d == floor(d);   //@ 判断换底后的log3n是否为整数，即n是否为3的倍数
    }
};

class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n < 1)
            return false;        
        while(n % 3 == 0)
            n /= 3;
        return n == 1;
    }
};
```

# 384. 打乱数组

[384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

 ```
class Solution {
    vector<int> _origin;
public:
    Solution(vector<int>& nums) : _origin(std::move(nums)){

    }
    
    /** Resets the array to its original configuration and return it. */
    vector<int> reset() {
        return _origin;
    }
    
    /** Returns a random shuffling of the array. */
    vector<int> shuffle() {
        if(_origin.empty())
            return {};
        vector<int> shuffled(_origin);
        int n = _origin.size();
        for(int i = n -1;i >= 0;--i)
            swap(shuffled[i],shuffled[rand() % (i+1)]);
        
        return shuffled;
    }
};
 ```

# 528. 按权重随机选择

[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

可以先使用 `partial_sum` 求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。这里的二分法可以用 `lower_bound` 实现。

```
class Solution {
    vector<int> _sums;
public:
    Solution(vector<int>& w) : _sums(std::move(w)){
        partial_sum(_sums.begin(),_sums.end(),_sums.begin());
    }
    
    int pickIndex() {
        int pos = (rand() % _sums.back()) + 1;
        return lower_bound(_sums.begin(),_sums.end(),pos) - _sums.begin();
    }
};
```

# 382. 链表随机节点

[382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

# 168. Excel表列名称

[168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

# 169. 多数元素

[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

# 67. 二进制求和

[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

# 238. 除自身以外数组的乘积

[238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

# 462. 最少移动次数使数组元素相等 II

[462. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)



[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

# 202. 快乐数

[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

借助 `set` ：

```
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> st;		
		while( n != 1)
		{
			int sum = 0;
			while(n)
			{
				sum += (n % 10) * (n % 10);
				n /= 10;
			}
			n = sum;
			if(st.count(n))
				break;
			st.insert(n);
		}
		return n == 1;
    }
};
```

快慢指针：

```
class Solution {
public:
    bool isHappy(int n) {
        int slow = n,fast = n;
		while(true)
		{			
			slow = next(slow);
			fast = next(fast);
			fast = next(fast);
			if(fast == slow)
				break;
		}		
		return slow == 1;
    }
	
	int next(int n)
	{
		int res = 0;
		while(n)
		{
			res += (n % 10) * (n % 10);
			n /= 10;
		}
		return res;
	}
};
```











