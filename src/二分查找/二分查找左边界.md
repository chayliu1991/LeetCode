# 二分查找左边界

利用二分法寻找左边界是二分查找的一个变体，这种类型可以分为两大类：

- 类型1：数组有序，但包含重复元素。数组部分有序，且不包含重复元素
- 类型2：数组部分有序，并且包含重复元素

类型1解题模板：

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left < right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] < target)
				left = mid + 1;
			else
				right = mid;				
		}
		return nums[left] == target ? left : -1;
	}
};
```

类型2解题模板：

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left < right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] < target)
				left = mid + 1;
			else if (nums[mid] > target)
				right = mid;
			else
				right--;
		}
		return nums[left] == target ? left : -1;
	}
};
```

# 278. 第一个错误的版本

[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

类型1：

```
class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1,right = n;
		while(left < right)
		{
			int mid = left + ((right - left) >> 1);
			if(isBadVersion(mid) == false)
				left = mid + 1;
			else
				right = mid;
		}
		return isBadVersion(left) == true ? left : -1; 
    }
};
```

# 658. 找到 K 个最接近的元素

[658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)

类型1：

```
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        //@ 左边界的位置范围 [0,arr.size()-k]
        int low = 0,high = arr.size() - k;
        while(low < high)
        {
            int mid = low + ((high - low) >> 1);
            //@ 比较谁更接近目标值
            if(x - arr[mid] > arr[mid + k] - x)
                low = mid + 1;
            else
                high = mid;            
        }
        return vector<int>(arr.begin()+low,arr.begin()+low+k);
    }
};
```

# 153. 寻找旋转排序数组中的最小值

[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

类型1：

```
class Solution {
public:
    int findMin(vector<int>& nums) {
		int left = 0,right = nums.size() - 1;
		while(left < right)
		{
			int mid = left + ((right - left) >> 1);
			if(nums[mid] > nums[right])
				left = mid + 1;
			else
				right = mid;
		}
		return nums[left];
    }
};
```

# 540. 有序数组中的单一元素

[540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

```
class Solution 
{
public:
    int singleNonDuplicate(vector<int>& nums) 
    {
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + (right - left)/2;
            if(mid % 2 == 1)               //防止mid是奇数，是的话则左移一位
                mid--;
            if(nums[mid] == nums[mid+1])   //说明目标数在[mid+2,right]
                left = mid + 2;
            else                           //否则目标数在[left,mid]
                right = mid;
        } 
        return nums[left];   
    }
};
```

# 154. 寻找旋转排序数组中的最小值 II

[154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

类型2：

```
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.empty())
            return - 1;
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > nums[right])
                left = mid + 1;
            else if(nums[mid] < nums[right])
                right = mid;
            else
                right --;
        }
        
        return nums[left];
    }
};
```

# 74. 搜索二维矩阵

[74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

```
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) 
            return false;
    
        int rows = matrix.size(),cols = matrix[0].size();
        
        //@ 二分查找行数
        int up = 0,down = rows - 1;
        while(up < down) 
        {
            int mid = up + ((down - up) >> 1);
            if(matrix[mid][cols-1] < target)  //@ 这一行的最后一个值比target还要小，收缩上边界
                   up = mid + 1;
            else 
                down = mid;
        }

        //@ 二分查找所在列
        int left = 0,right = cols - 1;
        while(left < right) 
        {
            int mid = left + ((right - left) >> 1);
            if(matrix[up][mid] < target)
                left = mid + 1;
            else 
                right = mid;
        }

        if(matrix[up][left] == target) 
            return true;
        return false;
    }
};
```

