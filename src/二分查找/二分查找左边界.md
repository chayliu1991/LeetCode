# 二分查找左边界

利用二分法寻找左边界是二分查找的一个变体，这种类型可以分为两大类：

- 类型1：数组有序，但包含重复元素。数组部分有序，且不包含重复元素
- 类型2：数组部分有序，并且包含重复元素

类型1解题模板：

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left < right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] < target)
				left = mid + 1;
			else
				right = mid;				
		}
		return nums[left] == target ? left : -1;
	}
};
```

类型2解题模板：

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left < right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] < target)
				left = mid + 1;
			else if (nums[mid] > target)
				right = mid;
			else
				right--;
		}
		return nums[left] == target ? left : -1;
	}
};
```

# 278. 第一个错误的版本

[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

类型1：

```
class Solution {
public:
    int firstBadVersion(int n) {
        int left = 1,right = n;
		while(left < right)
		{
			int mid = left + ((right - left) >> 1);
			if(isBadVersion(mid) == false)
				left = mid + 1;
			else
				right = mid;
		}
		return isBadVersion(left) == true ? left : -1; 
    }
};
```

# 658. 找到 K 个最接近的元素

[658. 找到 K 个最接近的元素](https://leetcode-cn.com/problems/find-k-closest-elements/)

类型1：

```
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        //@ 左边界的位置范围 [0,arr.size()-k]
        int low = 0,high = arr.size() - k;
        while(low < high)
        {
            int mid = low + ((high - low) >> 1);
            //@ 比较谁更接近目标值
            if(x - arr[mid] > arr[mid + k] - x)
                low = mid + 1;
            else
                high = mid;            
        }
        return vector<int>(arr.begin()+low,arr.begin()+low+k);
    }
};
```

# 153. 寻找旋转排序数组中的最小值

[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

类型1：

```
class Solution {
public:
    int findMin(vector<int>& nums) {
		int left = 0,right = nums.size() - 1;
		while(left < right)
		{
			int mid = left + ((right - left) >> 1);
			if(nums[mid] > nums[right])
				left = mid + 1;
			else
				right = mid;
		}
		return nums[left];
    }
};
```

# 154. 寻找旋转排序数组中的最小值 II

[154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

类型2：

```
class Solution {
public:
    int findMin(vector<int>& nums) {
        if(nums.empty())
            return - 1;
        int left = 0,right = nums.size() - 1;
        while(left < right)
        {
            int mid = left + ((right - left) >> 1);
            if(nums[mid] > nums[right])
                left = mid + 1;
            else if(nums[mid] < nums[right])
                right = mid;
            else
                right --;
        }
        
        return nums[left];
    }
};
```

