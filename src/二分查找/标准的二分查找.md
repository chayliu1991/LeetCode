# 标准的二分查找

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left <= right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] == target)
				return mid;
			else if (nums[mid] > target)
				right = mid - 1;
			else
				left = mid + 1;
		}
		return -1;
	}
};
```

注意：

- 因为循环条件中存在 `left == right` 的情况，因此每次必须改变 `left` 和 `right` 的指向，以防止进入死循环

- 求 `mid`  时，不采用  `(right + left) >>  1`，为了防止 `right + left` 溢出

- `left + ((right - left) >> 1)` ，对于目标区间长度为奇数而言，是处于正中间的节点，对于长度为偶数而言，是中间偏左的节点，当区间长度小于等于2时，`mid` 和 `left` 节点总是在同一侧，因此左右边界相遇时，只有下面两种情况：

  - `left` 和 `mid` 指向同一个数，`right` 指向下一个数
  - `left`，`mid`，`right` 指向同一个数

  