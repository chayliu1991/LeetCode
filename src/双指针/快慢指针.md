# 环形链表 II

[环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

快慢指针，首先判断链表是否有环，如果有环再找入口点。

判断是否有环：

当一个跑得快的人和一个跑得慢的人在一个圆形的赛道上赛跑，会发生什么？在某一个时刻，跑得快的人一定会从后面赶上跑得慢的人。

查找入口点：

![](../../img/circular_list.png)
$$
\begin{aligned}
2 \cdot \text { distance}(\text {tortoise}) &=\text {distance}(\text {hare}) \\
2(F+a) &=F+a+b+a \\
2 F+2 a &=F+2 a+b \\
F &=b
\end{aligned}
$$

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
         ListNode *fast= head,*slow = head;
		 do{
			if(fast == nullptr || fast->next == nullptr)
				return nullptr;			
			fast = fast->next->next;
			slow = slow->next;		 
		 }while(fast != slow);
		 
		 fast = head;
		 while(fast != slow)
		 {
			slow = slow->next;
			fast = fast->next;
		 }
		
		return fast;
    }
};
```

哈希解法：

```
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
		unordered_set<ListNode *> nodeSet;
		ListNode *node = head;
		while(node != nullptr)
		{
			if(nodeSet.find(node) != nodeSet.end())
				return node;
			nodeSet.insert(node);
			node = node->next;
		}
		
		return nullptr;
    }
};
```

# 移除元素

[移除元素](https://leetcode-cn.com/problems/remove-element/)

使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不满足指定的值，slow指针前进一步，这样不满足条件的整数都被移动到数组的前面。

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0,fast = 0,n = nums.size();
        while(fast < n)    
        {
            if(nums[fast] != val) 
                nums[slow++] = nums[fast];
            fast++;
        }                
        return slow;
    }
};
```

# 移动零

[移动零](https://leetcode-cn.com/problems/move-zeroes/)

使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不等于0，slow指针前进一步，这样不等于0的整数都被移动到数组的前面。

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0,fast = 0,n = nums.size();
        while(fast < n)
        {
            if(nums[fast] != 0)
                swap(nums[slow++],nums[fast]);
            fast++;
        }        
    }
};
```

# 删除排序数组中的重复项

[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第2个数字，如果快指针指向的数等于慢指针的前1个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 1, fast = 1, n = nums.size();
        if(n <= 1) return n;
        while(fast < n){
            if(nums[fast] != nums[slow - 1]) nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```

# 删除排序数组中的重复项 II

[删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第3个数字，如果快指针指向的数等于慢指针的前2个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 2, fast = 2, n = nums.size();
        if(n <= 2) return n;
        while(fast < n){
            if(nums[fast] != nums[slow - 2]) 
                nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```

# 回文链表

[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

使用快慢指针找到链表的中间节点，将链表分成两部分，并且反转后半部分，依次比较值：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr || head->next == nullptr) 
            return true;  //@ 空链表和单节点链表是回文链表
        ListNode* slow = head,*fast= head;
        //@ 快慢指针找到链表的中点
        for(;fast && fast->next;fast = fast->next->next,slow = slow->next);    
        ListNode* curr = slow,*next = nullptr,*pre = nullptr;
        //@ 翻转后半部分链表
        for(;curr;next = curr->next,curr->next = pre,pre = curr,curr = next);
        //@ 依次比较两个链表的对应元素
        for(ListNode* front=head,* back = pre;front && back;front = front->next,back = back->next)
            if(front->val != back->val) return false;
        return true;
    }
};
```

利用 `vector` 存储：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> store;
        ListNode* curr = head;
        while(curr != nullptr){
            store.push_back(curr->val);
            curr = curr->next;
        }
           
        int front = 0,back = store.size() - 1;
        while(front < back)
        {
            if(store[front] != store[back])
                return false;
            front++,back--;
        }
        return true;
    }
};
```

# 删除链表的倒数第N个节点

[删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

使用快慢指针，两者之间保持距离 n 个节点，快指针到末尾，慢指针就指向要删除的节点：

```
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *slow = dummy,*fast = dummy;
        while(n--)
            fast = fast->next;
        while(fast->next)
        {
             slow = slow->next;
             fast = fast->next;
        }
        slow->next = slow->next->next;
        return dummy->next;
    }
};
```

# 排序链表

[排序链表](https://leetcode-cn.com/problems/sort-list/)

归并排序：

```
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *slow = head,*fast = head->next;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode *mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head),sortList(mid)); 
    }

    ListNode* merge(ListNode* l1,ListNode* l2)
    {
        ListNode dummy(-1);
        ListNode* tail = &dummy;
        while(l1 && l2){
            if(l1->val > l2->val)
                swap(l1,l2);
            tail->next = l1;
            l1 = l1->next;
            tail = tail->next;
        }
        if(l1) tail->next = l1;
        if(l2) tail->next = l2;
        return dummy.next;
    }

};
```

