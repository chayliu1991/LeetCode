# 13 二叉树的最大深度

[13 二叉树的最大深度](https://www.nowcoder.com/practice/8a2b2bf6c19b4f23a9bdb9b233eefa73?tpId=190&&tqId=35335&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

递归：

````
class Solution {
public:

    int maxDepth(TreeNode* root) {
        if(root == nullptr)
			return 0;
		return max(maxDepth(root->left),maxDepth(root->right)) + 1;
    }
};
````

程序遍历：

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
			return 0;
		int res = 0;
		queue<TreeNode*> q;
        q.push(root);
		while(!q.empty())
		{
			res++;
			int n = q.size();
			for(int i = 0;i < n;i++)
			{
				auto it = q.front();
				q.pop();
				if(it->left)
					q.push(it->left);
				if(it->right)
					q.push(it->right);
			}
		}
		return res;
    }
};
```

# 14 二叉树的之字形层序遍历

[14 二叉树的之字形层序遍历](https://www.nowcoder.com/practice/47e1687126fa461e8a3aff8632aa5559?tpId=190&&tqId=35183&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode* root) {
        if(root == nullptr)
			return {};
		
		vector<vector<int>>  res;
		stack<TreeNode*> r2l,l2r;
		l2r.push(root);
		while(!r2l.empty() || !l2r.empty())
		{
			vector<int> level;
			if(!l2r.empty())
			{
				while(!l2r.empty())
				{
					auto it = l2r.top();
					l2r.pop();
					if(it->left)
						r2l.push(it->left);
					if(it->right)
						r2l.push(it->right);				
					level.push_back(it->val);
				}	
			}
			else
			{
				while(!r2l.empty())
				{
					auto it = r2l.top();
					r2l.pop();
					if(it->right)
						l2r.push(it->right);
					if(it->left)
						l2r.push(it->left);					
					level.push_back(it->val);
				}	
			}
			res.push_back(level);
		}
		return res;
    }
};
```

# 15 求二叉树的层序遍历

[15 求二叉树的层序遍历](https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=190&&tqId=35337&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) {
        if(root == nullptr)
			return {};
		
		queue<TreeNode*> q;
		q.push(root);
		vector<vector<int>> res;		
		while(!q.empty())
		{
			int n = q.size();
			vector<int> level;	
			for(int i = 0;i < n;i++)
			{						
				TreeNode* it = q.front();
				q.pop();	
				level.push_back(it->val);
				if(it->left)
					q.push(it->left);
				if(it->right)
					q.push(it->right);
			}			
			res.push_back(level);
		}
		return res;
    }
};
```

# 17 最长回文子串

[17 最长回文子串](https://www.nowcoder.com/practice/b4525d1d84934cf280439aeecc36f4af?tpId=190&&tqId=35207&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

中心扩展：

```
class Palindrome {
public:
    int getLongestPalindrome(string A, int n) {
		if (n <= 1) return n;
        int res = 0;
        for (int i = 0; i < n; ++i) {
            int l = i, r = i; //@ 以单字母为中心
            while (l >= 0 && r < n && A[l] == A[r])
                l--,r++;
             res = max(res,r-l-1);
            
            l = i, r = i + 1; //@ 以双字母为中心
            while (l >= 0 && r < n && A[l] == A[r]) 
                l--,r++;
            res = max(res,r-l-1);
        }
        return res;
    }
};
```

# 19 子数组的最大累加和问题

[19 子数组的最大累加和问题](https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=190&&tqId=35386&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution {
public:
    int maxsumofSubarray(vector<int>& arr) {
        if(arr.empty())
			return 0;
		int res = INT_MIN,curr = 0;
		for(int i = 0;i < arr.size();++i)
		{
			if(curr < 0)
				curr = arr[i];
			else
				curr += arr[i];			
			res = max(res,curr);
		}
		return res;
    }
};
```



