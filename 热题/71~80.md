

# 73 数组中出现次数超过一半的数字

[73 数组中出现次数超过一半的数字](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=190&&tqId=35371&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

排序：

```
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        unordered_map<int,int> dict;
        for(const auto n : numbers)
            dict[n]++;
        for(const auto d : dict)
        {
            if(d.second > numbers.size()/2)
                return d.first;
        }
        return 0;
    }
};
```

# 75 数组中只出现一次的数字

[75 数组中只出现一次的数字](https://www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811?tpId=190&&tqId=35201&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution {
public:
    void FindNumsAppearOnce(vector<int> data,int* num1,int *num2) {
		int Xor = 0;
		for(const auto x : data)	
			Xor ^= x;
        
		int diff = 1U;
		for(int i = 0; i < 32;i++)
		{
			if((diff << i) & Xor)
			{
				diff <<= i;
				break;
			}
		}
		
		for(const auto x : data)	
		{
			if(x & diff)
				*num1 ^= x;
			else
				*num2 ^= x;			
		}
    }
};
```

# 76 用两个栈实现队列

[76 用两个栈实现队列](https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=190&&tqId=35202&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty())
		{
			while(!stack1.empty())
			{
				stack2.push(stack1.top());
				stack1.pop();				
			}
		}
		
		int res = stack2.top();		
		stack2.pop();
		return res;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

# 78 翻转链表

[78 翻转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=190&&tqId=35203&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

递归：

```
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
		if(pHead == nullptr || pHead->next == nullptr)
			return pHead; //@ 此处必须返回 pHead，作为最终的结果
		ListNode* res = ReverseList(pHead->next); //@ 递归操作
        pHead->next->next = pHead; //@ 反转链表
		pHead->next = nullptr;    //@ 切断原有的连接
		return res;		
    }
};
```

非递归：

```
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
		if(pHead == nullptr || pHead->next == nullptr)
			return pHead;
		
		ListNode* curr = pHead,*prev = nullptr;
		while(curr)
		{			
			ListNode* t = curr->next;
			curr->next = prev;
			prev = curr; 
			curr = t;
		}
		return prev; //@ 原链表最后一个节点，反转后的头节点
    }
};
```

