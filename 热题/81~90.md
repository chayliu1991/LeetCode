# 81 二叉搜索树的第k个结点

[81 二叉搜索树的第k个结点](https://www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a?tpId=190&&tqId=35205&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

中序遍历：

```
class Solution {
public:
    TreeNode* KthNode(TreeNode* pRoot, int k)
    {
        if(k <= 0)
            return nullptr;
        vector<TreeNode*> inorderV;
        InOrder(pRoot,inorderV);
		if(inorderV.size() < k)
			return nullptr;
        return inorderV[k-1];
    }
     
    void InOrder(TreeNode* root,vector<TreeNode*>& res)
    {
        if(root == nullptr) 
			return;
        InOrder(root->left,res);
		res.push_back(root);
        InOrder(root->right,res);
    }     
};
```

优化：

```

class Solution {
public:
    TreeNode* res = nullptr; 
    TreeNode* KthNode(TreeNode* root, int k)
    {
        dfs(root,k);
        return res;       
    }
    void dfs(TreeNode* root,int &k)
    {
        if(root == nullptr)
			return;
        dfs(root->left,k);        
        k--;
        if(k==0)
        {
            res = root;
            return;
        }          
        dfs(root->right,k);
    }    
};
```

# 87 丢棋子问题

[87 丢棋子问题](https://www.nowcoder.com/practice/d1418aaa147a4cb394c3c3efc4302266?tpId=190&&tqId=35592&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Solution {
public:
    int solve(int n, int k) {
        if(n < 1) 
			return 0;
        if(k == 1) 
			return n;
        int logtimes = log2(n) + 1;
        if( k >= logtimes) 
			return logtimes;
        vector<int>f(k+1,0);
        int cnt=0;
        while(f[k] < n)
        {
            ++cnt;
            for(int i = k;i > 0;--i)
				f[i] += f[i-1] + 1;
        }
        return cnt;
    }
};
```

# 88 寻找第K大

[88 寻找第K大](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=190&&tqId=35209&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

```
class Finder {
public:
    //@ 按照从大到小排序
    void quick_sort(vector<int>& nums, int left, int right)
    {
        if (left < right)
        {
            int i = left, j = right, pivot = nums[left];
            while (i < j)
            {
                while (i < j && nums[j] <= pivot)
                    j--;
                if (i < j)
                    nums[i++] = nums[j];

                while (i < j && nums[i] >= pivot)
                    i++;
                if (i < j)
                    nums[j--] = nums[i];
            }
            nums[i] = pivot;  //@ pivot 在正确的位置上，并且将数组划分两半
            quick_sort(nums, left, i - 1);
            quick_sort(nums, i + 1, right);
        }
    }

    int findKth(vector<int> a, int n, int K) {
        if (n <= 0 || K <= 0 || n < K)
            return -1;
        quick_sort(a, 0, n - 1);
        return a[K - 1];
    }
};
```

# 90 设计getMin功能的栈

[90 设计getMin功能的栈](https://www.nowcoder.com/practice/c623426af02d4c189f92f2a99647bd34?tpId=190&&tqId=35210&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

双栈：

```
class Solution {
	stack<int> data_,minV_;
public:
    vector<int> getMinStack(vector<vector<int> >& op) {
        vector<int> res;
        for (const auto x : op)
        {
            if (x[0] == 1)
            {
                data_.push(x[1]);
                if (minV_.empty() || x[1] < minV_.top())  //@ 注意此处必须判空
                    minV_.push(x[1]);
                else
                    minV_.push(minV_.top());
            }
            else if (x[0] == 2)
            {
                data_.pop();
                minV_.pop();
            }
            else
            {
                res.push_back(minV_.top());
            }
        }
        return res;
    }
};
```

