#  03. 数组中重复的数字

[ 03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

```
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
		unordered_set<int> s;
		for(const auto n : nums)
		{
			if(s.find(n) != s.end())
				return n;
			s.insert(n);
		}	
		return -1;
    }
};
```

# 04. 二维数组中的查找

[04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
		if(matrix.empty() || matrix[0].empty())
			return false;
		int rows = matrix.size(),cols = matrix[0].size();
		int i = 0,j = cols - 1;
		while(i < rows && j >= 0)
		{
			if(matrix[i][j] == target)
				return true;
			else if(matrix[i][j] > target)
				j--;
			else
				i++;
		}	
		return false;
    }
};
```

# 05. 替换空格

[ 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

```
class Solution {
public:
    string replaceSpace(string s) {
		string res;
		for(const auto c : s)
		{
			if(c !=' ')
				res += c;
			else
				res += "%20";
		}
		return res;
    }
};
```

# 06. 从尾到头打印链表

[06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

```
class Solution {
public:
    vector<int> reversePrint(ListNode* head) {
        vector<int> res;
        while(head != nullptr)
        {
            res.push_back(head->val);
            head = head->next;
        }

        reverse(res.begin(),res.end());
        return res;
    }
};
```

# 07. 重建二叉树

[07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
		if(preorder.size() != inorder.size() || preorder.empty())
			return nullptr;
		
		TreeNode* root = new TreeNode(preorder[0]);
		int pos = 0,cnt = 0;
		for(int i =0;i < inorder.size();i++)
		{
			if(inorder[i] == root->val)
			{
				pos = i;
				break;
			}
			cnt++;
		}
	
		vector<int> LI(inorder.begin(),inorder.begin()+cnt);
		vector<int> RI(inorder.begin()+cnt+1,inorder.end());
		vector<int> LP(preorder.begin()+1,preorder.begin()+cnt+1);
		vector<int> RP(preorder.begin()+cnt+1,preorder.end());
		
		root->left = buildTree(LP,LI);
		root->right = buildTree(RP,RI);		
		return root;
    }
};
```

























