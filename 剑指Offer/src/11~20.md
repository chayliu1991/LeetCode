# 11. 旋转数组的最小数字

[11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

```
class Solution {
public:
    int minArray(vector<int>& numbers) {
		if(numbers.empty())
			return 0;
		int n = numbers.size();
		int res = numbers[0];
		for(int i = 1;i < n;i++)
		{
			if(numbers[i] < res)
				return numbers[i];
		}
		return res;
    }
};
```

# 12. 矩阵中的路径

[12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```
class Solution {
	int str_len;
public:
    bool exist(vector<vector<char>>& board, string word) {
		if(board.empty() || board[0].empty())
			return false;
		str_len = word.length();
		int rows = board.size(),cols = board[0].size();
		vector<vector<bool>> visited(rows,vector<bool>(cols));
		int match_len = 0;
		for(int i = 0;i < rows;i++)
		{
			for(int j = 0;j < cols;j++)
			{
				if(_exist(board,word,visited,i,j,match_len))
					return true;
			}
		}
		return false;	
    }
	
	bool _exist(const vector<vector<char>>& board,const string& word,vector<vector<bool>>& visited,int i,int j,int match_len)
	{
		if(str_len == match_len)
			return true;
		bool hit = false;
		if(i >=0 && j >= 0 && i < board.size() && j < board[0].size() &&
			board[i][j] == word[match_len] && visited[i][j] == false)
		{
			visited[i][j] = true;
			match_len += 1;			
			hit = _exist(board,word,visited,i+1,j,match_len) ||
					  _exist(board,word,visited,i-1,j,match_len) ||
					  _exist(board,word,visited,i,j+1,match_len) ||
					  _exist(board,word,visited,i,j-1,match_len);
			if(hit == false)
			{
				visited[i][j] = false;
				match_len -= 1;
			}
		}
		return hit;
	}	
};class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        if(word.empty()) return false;
        for(int i=0; i<board.size(); ++i)
        {
            for(int j=0; j<board[0].size(); ++j)
            {
                if(dfs(board, word, i, j, 0)) 
					return true;
            }
        }
        return false;
    }
	
    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int len)
    {
        //@ 如果索引越界，或者值不匹配，返回false
        if(i<0 || i >= board.size() || j<0 || j >= board[0].size() || board[i][j] != word[len]) 
			return false;
        if(len == word.length() - 1) 
			return true;
        char temp = board[i][j]; 
        board[i][j] = '\0'; //@ 将当前元素标记为'\0'，即一个不可能出现在word里的元素，表明当前元素不可再参与比较
        if(dfs(board,word,i-1,j,len+1) 		|| 
			dfs(board,word,i+1,j,len+1) 	|| 
			dfs(board,word,i,j-1,len+1)   	|| 
			dfs(board,word,i,j+1,len+1))
        {
            return true;
        }
		
        //@ 如果不匹配
		board[i][j] = temp; //@ 将当前元素恢复回其本身值
        return false;
    }
};
```

