# 51. 数组中的逆序对

[51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并：

```
class Solution {
private:
    int g_count=0;
public:
    void mergesort(int lo,int hi,vector<int>& nums,vector<int>& tmp){
        if(lo>=hi) return;
        int mid=lo+(hi-lo)/2;
        mergesort(lo,mid,nums,tmp);
        mergesort(mid+1,hi,nums,tmp);
        int i=lo,j=mid+1;
        for(int k=lo;k<=hi;k++){
            if(i>mid) tmp[k]=nums[j++];//nums[i]到nums[mid]已经全部填入tmp
            else if(j>hi) tmp[k]=nums[i++];//nums[mid+1]到nums[j]已经全部填入tmp
            else if(nums[i]>nums[j]) {
                tmp[k]=nums[j++];
                g_count+=mid-i+1;//i肯定小于j，且nums[i]到nums[mid]是升序排序，如果nums[i]>nums[j]，说明从nums[i]到nums[mid]和nums[j]都是逆序对
            }
            else tmp[k]=nums[i++];
        }
        for(int m=lo;m<=hi;m++) nums[m]=tmp[m];//
    }
    
    int reversePairs(vector<int>& nums) {
        vector<int> tmp(nums.size(),0);//就是用来记录某个递归函数merge后的情况，然后复制更新nums
        mergesort(0,nums.size()-1,nums,tmp);
        return g_count;
    }
};
```

# 52. 两个链表的第一个公共节点

[52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

set：

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode * curr = headA;
        set<ListNode *> s;
        while(curr)
        {
            s.insert(curr);
            curr = curr->next;
        }
        curr = headB;
        while(curr)
        {
            if(s.count(curr))
                return curr;
            curr = curr->next;
        }    

        return nullptr;
    }
};
```

双指针：

- `L1  +  L2  =  L2  +  L1`
- `L1  +  L2 + C = L2 + L1 +  C`

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode *r1=headA;
    ListNode *r2=headB;
    if(!headB || !headA)
        return NULL;
    while(r1!=r2){
        r1=r1!=NULL?r1->next:headB;
        r2=r2!=NULL?r2->next:headA;
    }
    return r1;
    }
};
```

# 53 - I. 在排序数组中查找数字 I

[53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

C++库函数：

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        auto up = upper_bound(nums.begin(),nums.end(),target);
        auto low = lower_bound(nums.begin(),nums.end(),target);
        return up - low;
    }
};
```

C++库函数：

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        return count(nums.begin(),nums.end(),target);
    }
};
```

二分查找：

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        if(nums.size() == 0)
            return 0;
        int l = first(nums, target);
        if (l == -1)
            return 0;
        int r = last(nums, target);
        return r - l + 1;
    }

    int first(vector<int>& nums, int target){
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target)
                r = mid - 1;
            else if(nums[mid] > target)
                r = mid - 1;
            else  // nums[mid] < target
                l = mid + 1;
        }
        if(l >= nums.size() || nums[l] != target) // if(l == nums.size() || nums[r + 1] != target)
            return -1;
        return l;
    }

    int last(vector<int>& nums, int target){
        int l = 0;
        int r = nums.size() - 1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == target)
                l = mid + 1;
            else if(nums[mid] < target)
                l = mid + 1;
            else // nums[mid] > target
                r = mid - 1;
        }
        if(r < 0 || nums[l - 1] != target) // if(r == -1 || nums[r] != target)
            return -1;
        return r;
    }
};
```

# 53 - II. 0～n-1中缺失的数字

[ 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

前 n 项和：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
		int n = nums.size();
        int expect = (n * (n+1)) >> 1;
		int sum = accumulate(nums.begin(),nums.end(),0);
		return expect - sum;
    }
};
```

遍历：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        for(int i = 0;i < nums.size();++i)
            if(i != nums[i])
                return i;
        return nums.size();
    }
};
```

二分：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int left = 0, right = nums.size();
        while(left < right)
        {
            int mid = left + ((right - left) >> 1);
            if(mid == nums[mid]) 
                left = mid + 1;
            else 
                right = mid;
        }
        return left;
    }
};
```

# 54. 二叉搜索树的第k大节点

[54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

二叉搜索树前序遍历：

```
class Solution {
	vector<int> inoderT;
public:
	void inoder(TreeNode* root)
	{
		if(root == nullptr)
			return;
		inoder(root->left);
		inoderT.push_back(root->val);
		inoder(root->right);
	}
	
    int kthLargest(TreeNode* root, int k) {
		inoder(root);
		if(inoderT.size() < k)
			return -1;
		reverse(inoderT.begin(),inoderT.end());
		return inoderT[k-1];
    }	
};
```

栈：

```
class Solution {
public:
    int kthLargest(TreeNode* root, int k) {
        stack<TreeNode*> stk;
        TreeNode* curr = root;
        while(curr || stk.size())
        {
            while(curr) 
            {
                stk.push(curr);
                curr = curr->right;
            }
            curr = stk.top();
            stk.pop();
            if(-- k == 0) 
                return curr->val;
            curr = curr->left;
        }
        return root->val;
    }
};
```

# 55 - I. 二叉树的深度

[55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

递归：

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        
        return max(maxDepth(root->left),maxDepth(root->right)) + 1;
    }
};
```

BFS：

```
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr)
            return 0;
        queue<TreeNode*> q;
        q.push(root);
        int res = 0;
        while(!q.empty())
        {
            int n = q.size();
            for(int i = 0;i < n;i++)
            {
                TreeNode* node = q.front();
                q.pop();
                if(node->left)
                    q.push(node->left);
                if(node->right)
                    q.push(node->right);
            }
            res ++;
        }
        return res;
    }
};
```

# 55 - II. 平衡二叉树

[55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

```
class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(root == nullptr)
            return true;

        if(abs(depth(root->left)-depth(root->right)) > 1)
            return false;
        return isBalanced(root->left) && isBalanced(root->right);
    }

    int depth(TreeNode* root)
    {
        if(root == nullptr)
            return 0;
        return max(depth(root->left), depth(root->right)) + 1;
    }
};
```















