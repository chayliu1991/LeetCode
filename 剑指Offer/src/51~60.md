# 51. 数组中的逆序对

[51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

归并：

```
class Solution {
private:
    int g_count=0;
public:
    void mergesort(int lo,int hi,vector<int>& nums,vector<int>& tmp){
        if(lo>=hi) return;
        int mid=lo+(hi-lo)/2;
        mergesort(lo,mid,nums,tmp);
        mergesort(mid+1,hi,nums,tmp);
        int i=lo,j=mid+1;
        for(int k=lo;k<=hi;k++){
            if(i>mid) tmp[k]=nums[j++];//nums[i]到nums[mid]已经全部填入tmp
            else if(j>hi) tmp[k]=nums[i++];//nums[mid+1]到nums[j]已经全部填入tmp
            else if(nums[i]>nums[j]) {
                tmp[k]=nums[j++];
                g_count+=mid-i+1;//i肯定小于j，且nums[i]到nums[mid]是升序排序，如果nums[i]>nums[j]，说明从nums[i]到nums[mid]和nums[j]都是逆序对
            }
            else tmp[k]=nums[i++];
        }
        for(int m=lo;m<=hi;m++) nums[m]=tmp[m];//
    }
    
    int reversePairs(vector<int>& nums) {
        vector<int> tmp(nums.size(),0);//就是用来记录某个递归函数merge后的情况，然后复制更新nums
        mergesort(0,nums.size()-1,nums,tmp);
        return g_count;
    }
};
```

# 52. 两个链表的第一个公共节点

[52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

set：

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode * curr = headA;
        set<ListNode *> s;
        while(curr)
        {
            s.insert(curr);
            curr = curr->next;
        }
        curr = headB;
        while(curr)
        {
            if(s.count(curr))
                return curr;
            curr = curr->next;
        }    

        return nullptr;
    }
};
```













