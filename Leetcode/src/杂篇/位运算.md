# 概述

## 判断奇偶性

```
if(1 == n & 0x01)  //@ n 是奇数
```

## 交换两个数

```
x ^= y;
y ^= x;
x ^= y;
```

## 异或

```
n ^ n = 0; //@ 相同的数异或为0
0 ^ n = n; //@ 任何数和0异或为其本身
```

## 变换符号

```
int sign_reversal(int n)
{
	return ~n + 1;
}
```

## 取绝对值

```
int abs(int n)
{
	int i = n >> 31;
	return i == 0 ? n : (~n + 1); //@ 最高位是0，表示正数
}
```

## 最右边的1

```
n &= (n-1);  //@ 去掉最右边的1
x &= (-x);	//@ 得到最右边的的1，并且将其他1设置为0
```

# [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y;
        while(n)
        {
            res++; 
            n &= (n-1);
        }
        return res;
    }
};
```

# [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

```
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for(int i = 0;i < 32;i++)
        {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
};
```

# [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(auto const num : nums)
            res ^= num;
        return res;
    }
};
```

# [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < 32;i++)
        {
            int cnt = 0;
            for(const auto num : nums)
                cnt += (num >> i) & 1;
            res |= (cnt % 3) << i;
        }
        return res;
    }
};
```

# [260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

```
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xnor = 0;
        for(const auto num : nums)
            xnor ^= num;
        
        int last_one = xnor & (-xnor);
        int res1 = 0,res2 = 0;
        for(const auto num : nums)
        {
            if(num & last_one)
                res1 ^= num;
            else
                res2 ^= num;
        }
        return {res1,res2};
    }
};
```

# [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

```
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int>  res(num+1,0);
        for(int i = 1;i <= num;i++)
        {
			//@ 如果二进制的最后一位为1,那么它含有1的个数则为 dp[i-1] + 1
			//@ 如果二进制的最后一位为0，那么它含有1 的个数和其算术右移结果相同，即 dp[i>>1]
            res[i] = i & 1 ? res[i-1] + 1 : res[i>>1];
        }
        return res;
    }
};
```

# [268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)

等差数列前n项和：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
		int n = nums.size();
        int expect = (n * (n + 1)) / 2;
		int sum = accumulate(nums.begin(),nums.end(),0);
		return expect - sum;
    }
};
```

异或计算：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size(); //@ 注意初始化值
        for(int i = 0;i < nums.size(); ++i)
            res = (res ^ i ^ nums[i]);  // a^b^b = a
        return res;
    }
};
```

# [693. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

如果一个数字 `n` 的二进制满足交替数，则  `(n ^ n >> 1)` 是一个全 `1` 的序列，上面的结果加 `1` ，则会将与 `n` 同宽度的二进制位设置为0：

```
class Solution {
public:
    bool hasAlternatingBits(int n) {
        long num = (n ^ (n >> 1));
        return (n & (num + 1)) == 0;
    }
};
```

# 476. 数字的补数

 [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)