# 概述

## 判断奇偶性

```
if(1 == n & 0x01)  //@ n 是奇数
```

## 交换两个数

```
x ^= y;
y ^= x;
x ^= y;
```

## 异或

```
n ^ n = 0; //@ 相同的数异或为0
0 ^ n = n; //@ 任何数和0异或为其本身
```

## 变换符号

```
int sign_reversal(int n)
{
	return ~n + 1;
}
```

## 取绝对值

```
int abs(int n)
{
	int i = n >> 31;
	return i == 0 ? n : (~n + 1); //@ 最高位是0，表示正数
}
```

# [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int res = 0,n = x ^ y;
        while(n)
        {
            res++; 
            n &= (n-1);
        }
        return res;
    }
};
```

# [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

```
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t res = 0;
        for(int i = 0;i < 32;i++)
        {
            res = (res << 1) + (n & 1);
            n >>= 1;
        }
        return res;
    }
};
```

# [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(auto const num : nums)
            res ^= num;
        return res;
    }
};
```

# [137. 只出现一次的数字 II](https://leetcode-cn.com/problems/single-number-ii/)

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0; i < 32;i++)
        {
            int cnt = 0;
            for(const auto num : nums)
                cnt += (num >> i) & 1;
            res |= (cnt % 3) << i;
        }
        return res;
    }
};
```

# 260. 只出现一次的数字 III

[260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)

利用 `set`：

```
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        unordered_set<int> s;        
        for(const auto n : nums)
        {
            if(s.find(n) != s.end())
            {   
                s.erase(n);
                continue;
            }                
            s.insert(n);
        }
        vector<int> res(s.begin(),s.end());
        return res;
    }
};
```

位运算：

- `x ^ x =0`
- `x & (-x)` 可以得到最右边的的 `1`，并且将其他 `1` 设置为 `0`

```
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int xnor = 0;
        for(int num : nums)
            xnor ^= num;
        
        int last_one = xnor & (-xnor);        
        int res1 = 0, res2 = 0;        
        for(int i : nums)
        {
            if(i & last_one) 
                res1 ^= i;
            else 
                res2 ^= i;
        }
        return {res1, res2};
    }
};
```

# 342. 4的幂

[342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

```
class Solution {
public:
    bool isPowerOfFour(int num) {
        while(num && num % 4 == 0)
            num /= 4;
        return num == 1;
    }
};
```

 4 的幂次方的数的二进制表示 1 的位置都是在奇数位。符合这两个条件的二进制数是：

```
1010101010101010101010101010101 //@ 0x55555555
```

并且这个数应该首先满足能被2整除：

```
class Solution {
public:
    bool isPowerOfFour(int num) {
        if(num <= 0)
            return false;
        
        //@ 不能被2整除
        if(num & num - 1)
            return false;
        if((num & 0x55555555) == num)
            return true;
        return false;
    }
};
```

# 318. 最大单词长度乘积

[318. 最大单词长度乘积](https://leetcode-cn.com/problems/maximum-product-of-word-lengths/)

```
class Solution {
public:
    int str2int(const string& s) {
        int res = 0;
        for (auto c : s)
            res |= 1 << (c - 'a');
        return res;
    }
    int maxProduct(vector<string>& words) {
        int N = words.size();
        vector<int> v(N, 0);
        for (int i = 0; i < N; ++i)
            v[i] = str2int(words[i]);
        int res = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < i; ++j) {
                if ((v[i] & v[j]) == 0 && words[i].size() * words[j].size() > res)
                    res = words[i].size() * words[j].size();
            }
        }
        return res;
    }
};
```

# 338. 比特位计数

[338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

方法一：

```
class Solution {
public:
    int count(int num)
    {
        int res = 0;
        while(num)
        {
            res ++;
            num &= num - 1;
        }
        return res;
    }

    vector<int> countBits(int num) {
        vector<int> res;
        for(int i = 0;i <= num;i++)
            res.push_back(count(i));
        return res;
    }
};
```

方法二：

动态规划：

定义一个数组 `dp`，其中 `dp[i]`  表示数字 `i` 的二进制含有1 的个数。对于第 `i` 个数字，如果它二进制的最后一位为`1`，那么它含有 `1`  的个数则为 `dp[i-1] + 1`；如果它二进制的最后一位为0，那么它含有1 的个数和其算术右移结果相同，即 `dp[i>>1]`。

```
class Solution {
public:
    vector<int> countBits(int num) {
       vector<int>  res(num+1,0);
       for(int i = 0;i <= num;++i)
            res[i] = i & 1 ? res[i-1] + 1 : res[i>>1];
       return res;
    }
};
```

# 268. 缺失数字

[268. 缺失数字](https://leetcode-cn.com/problems/missing-number/)

等差数列前n项和：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int sum = accumulate(nums.begin(),nums.end(),0);
        int n = nums.size();
        int Sum = (n+1) * n /2;
        return Sum - sum;
    }
};
```

异或计算：

```
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int res = nums.size(); //@ 注意初始化值
        for(int i = 0;i < nums.size(); ++i)
            res = (res ^ i ^ nums[i]);  //@ A ^ B ^ B = B
        return res;
    }
};
```

# 693. 交替位二进制数

[693. 交替位二进制数](https://leetcode-cn.com/problems/binary-number-with-alternating-bits/)

方法1：

```
class Solution {
public:
    bool hasAlternatingBits(int n) {
		int mark = n & 0x01;
		n >>= 1;
		while(n)
		{
			if((n & 0x01) == mark)
				return false;
			mark = n & 0x01;
			n >>= 1;
		}
		return true;
    }
};
```

方法2：

如果一个数字 `n` 的二进制满足交替数，则  `(n ^ n >> 1)` 是一个全 `1` 的序列，上面的结果加 `1` ，则会将与 `n` 同宽度的二进制位设置为0：

```
class Solution {
public:
    bool hasAlternatingBits(int n) {
		n = (n ^ (n >> 1));
		return (n & ((long)n + 1)) == 0;
    }
};
```

# 476. 数字的补数

 [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)