# 概述

左右指针常常应用于数组或者字符中，一般是两个索引值，分别初始化为 left = 0, right = length - 1 。

# [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)



```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        vector<int> res;
        int left = 0,right = numbers.size()-1;
        while(left < right)
        {
            if(numbers[left] + numbers[right] == target)
                return {left+1,right+1};
            else if(numbers[left] + numbers[right] > target)
                right--;
            else
                left++;
        }
        return res;
    }
};
```

# [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        if(n < 3)
            return {};
        sort(nums.begin(),nums.end());        
        vector<vector<int>> res;

        for(int i = 0;i < n -2 ;i++)
        {
            //@ 后面的数累加和都是大于0的，不可能等于0，提前结束
            if(nums[i] > 0)
                break;  

            //@ 计算的起点应该不同，去重
            if(i > 0 && nums[i] == nums[i-1])
                continue;

            int left = i+1,right = n-1;
            int target = -nums[i];
            while(left < right)
            {
                int sum = nums[left] + nums[right];
                if(sum == target)
                {
                    vector<int> t{nums[i],nums[left],nums[right]};
                    res.push_back(t);
                    left ++,right--;  //@ 必须累加,否则可能死循环

                    //@ 去重
                    while(left < right && nums[left] == nums[left-1])
                        left++;
                    while(left < right && nums[right] == nums[right+1])
                        right--;
                }
                else if(sum > target)
                    right--;
                else
                    left++;   
            }
        }
        return res;
    }
};
```

# [16. 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

```
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int n = nums.size();
        if(n <= 3)
            return accumulate(nums.begin(),nums.end(),0);
        
        int res = nums[0] + nums[1] + nums[2];
        int diff = abs(res - target);        
        sort(nums.begin(),nums.end());

        for(int i = 0;i < n -2;i++)
        {
            int left = i+1,right = n-1;
            while(left < right)
            {
                int sum = nums[i] + nums[left] + nums[right];
                if(abs(sum - target) < diff)
                {
                    diff = abs(sum - target);
                    res = sum; 
                }

                if(sum > target)
                    right--;
                else if(sum < target)
                    left++;
                else
                    return target;
            }           
        }
        return res;
    }
};
```

# [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int n = nums.size();
        if(n < 4)
            return {};

        vector<vector<int>> res;
        sort(nums.begin(),nums.end());        
        for(int i = 0;i < n - 3;++i)
        {
            for(int j = i+1;j < n - 2;j++)
            {
                int left = j + 1,right = n -1;
                int x = target - nums[i] - nums[j]; //@ 目标值
                while(left < right)
                {
                    int sum = nums[left] + nums[right];
                    if(sum > x) 
						right--;
                    else if(sum < x) 
						left++;
                    else
                    {
                        vector<int> t{nums[i],nums[j],nums[left],nums[right]};
                        res.push_back(t);
                        left++,right--;
						
						//@ 去重
                        while(left < right && nums[left] == nums[left -1]) 
							left++;
                        while(left < right && nums[right] == nums[right + 1]) 
							right--;
                    } 
                }
                while(j < n-2 && nums[j] == nums[j+1]) 
					j++;
            }
            while(i < n-3 && nums[i] == nums[i+1]) 
				i++;
        }
        return res;
    }
};
```




# 盛最多水的容器

[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

两条垂直的线和X轴组成一个容器，灌水多少不仅与两个柱子的高度有关，也与两个柱子的距离有关，公式：`S(i,j) = min(ai, aj) * (j-i)`，容器不能倾斜，求容纳最多水的两个线组合。定义left和right两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离。

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0,right = height.size() - 1;
        int res = 0;
        while(left < right)
        {
            int temp = min(height[right],height[left]);
            res = max(res,temp*(right - left));
            if(height[right] < height[left]) right --;
            else left++;
        }
        return res;
    }
};
```

# 合并两个有序数组

[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

双指针解法，利用了后置 `--` 的运算特性：

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		int curr = m-- + n-- - 1;
		while(m>=0 && n >=0)		
			nums1[curr--] = (nums1[m] > nums2[n] ? nums1[m--] : nums2[n--]);	
		
		while(n>=0)
			nums1[curr--] = nums2[n--];				
    }
};
```

# 平方数之和

[平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

```
class Solution {
public:
    bool judgeSquareSum(int c) {
        long left = 0,right = sqrt(c);
        while(left <= right)
        {
            long square = left*left + right*right;
            if(square == c)
                return true;
            else if(square > c)
                right--;
            else    
                left++;            
        }
        return false;
    }
};
```

# 验证回文字符串 Ⅱ

[验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

删除的话，左右都有被删除的机会，所以要一起考虑：

```
class Solution {
public:
    bool validPalindrome(string s) {        
        int left = 0,right = s.length() - 1;
        while(left < right)
        {
            if(s[left] == s[right])
                left++,right--;
            else
                return helper(s,left+1,right) || helper(s,left,right-1);
        }
        return true;
    }

    bool helper(string& s,int low,int high)
    {
        while(low < high)    
            if(s[low++] != s[high--])
                return false;   
        return true;
    } 
};
```

# 通过删除字母匹配到字典里最长单词

[通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

```
class Solution {
public:
    string findLongestWord(string s, vector<string>& d) {
        string best;
        for(auto const & str : d)
        {
            int l1 = best.size(),l2 = str.size();
            if(l1 > l2 || (l1 == l2 && best.compare(str) < 0))
                continue;
            if(isSubstr(s,str))
                best = str;
        }
        return best;
    }

    bool isSubstr(string& s,string str)
    {
        int i = 0,j = 0;
        while(i < s.length() && j < str.length()){
            if(s[i] == str[j])
                j++;
            i++;
        }
        return j == str.length();
    }
};
```

#### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)





