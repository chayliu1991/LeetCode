# 两数之和 II - 输入有序数组

[两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

左右指针解法：

需要两个指针，一个指向开头，一个指向末尾，然后向中间遍历，如果指向的两个数相加正好等于target的话，直接返回两个指针的位置即可，若小于target，左指针右移一位，若大于target，右指针左移一位，以此类推直至两个指针相遇停止。

```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if(numbers.empty()) return {};
        int left = 0,right = numbers.size()-1;
        while(left < right)
        {
            int sum = numbers[left] + numbers[right];
            if( sum == target)
                return {left+1,right+1};
            else if(sum > target)
                --right;
            else
                ++left;
        }
        return {};
    }
};
```

哈希解法：

```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        if(numbers.empty()) return {};
        int n = numbers.size();
        unordered_map<int,int> dict;
        for(int i=0;i<n;++i)
        {
            int diff = target - numbers[i];
            if(dict.find(diff) != dict.end())
                return {dict[diff],i+1};
            
            dict[numbers[i]] = i+1;
        }
        return {};
    }
};
```

# 最接近的三数之和

[最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

尝试把三数和问题转化为两数和问题：同样先对数组排序，设置三个指针i,left,right，i指针指向第一个数x，则left,right要指向数组中剩余数中的两个，并且指向的两数和为-x，从而转化为两数和问题。

```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        int n = nums.size();
        if(n <= 2) return res; //@ 数据个数不足

        sort(nums.begin(),nums.end());

        for(int i=0;i<n-2;++i)
        {
            if(nums[i] > 0) break; //@ 第一个数大于0，排序后面的数都比它大，不可能凑出来
            if(i>0 && nums[i] == nums[i-1]) continue; //@ 去掉重复的数字
            int target = -nums[i]; //@ 转化为 two sum
            int left = i+1,right = n-1;
            while(left < right)
            {
                int sum = nums[left] + nums[right];
                if(sum > target)  right--;
                else if(sum < target) left++;
                else
                {
                    vector<int> tmp{nums[i],nums[left],nums[right]};
                    res.push_back(tmp);
                    left++,right--;
                    //@ 下面的操作是为了去重
                    while(left < right && nums[left] == nums[left-1]) left++; 
                    while(left < right && nums[right] == nums[right+1]) right--; 
                }
            }
        }

        return res;
    }
};
```

# 最接近的三数之和

[最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

我们要保证当前三数和跟给定值之间的差的绝对值最小，所以我们需要定义一个变量small用来记录差的绝对值。

```
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        int n = nums.size(),res = INT_MIN,samll = INT_MAX;
        sort(nums.begin(),nums.end());
        for(int i=0;i<n-2;i++)
        {
            int left = i+1,right = n-1;
            while(left < right)
            {
                //@ 记录最小的差值
                int temp = nums[left] + nums[right] + nums[i];
                if(abs(temp - target) < samll)
                {
                    res = temp;
                    samll =abs(temp - target);
                }

                if(temp > target) right --;
                else if(temp < target) left ++;
                else return target; //@ 差值是0，直接返回
            }
            while(i+1 < n-2 && nums[i] == nums[i+1]) i++; //@ 去重
        }
        return res;
    }
};
```

# 四数之和

[四数之和](https://leetcode-cn.com/problems/4sum/)

尝试把四数和问题转化为两数和问题：同样先对数组排序，设置四个指针k,i,left,right，k指针指向第一个数，i指针指向第二个数,则left,right要指向数组中剩余数中的两个，从而转化为两数和问题。

```
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        int n = nums.size();
        if( n <= 3) return res;

        sort(nums.begin(),nums.end());
        for(int k = 0;k < n-3;++k)
        {
            for(int i = k+1;i < n-2;i++)
            {
                int left = i + 1,right = n -1;
                int ret = target - nums[k] - nums[i];
                while(left < right)
                {
                    int temp = nums[left] + nums[right];
                    if(temp > ret) right--;
                    else if(temp < ret) left++;
                    else
                    {
                        vector<int> tmp{nums[k],nums[i],nums[left],nums[right]};
                        res.push_back(tmp);
                        left++;
                        right--;
                        while(left < right && nums[left] == nums[left -1]) left++;
                        while(left < right && nums[right] == nums[right + 1]) right--;
                    } 
                }
                while(i+1 < n-2 && nums[i] == nums[i+1]) i++;
            }
            while(k+1 < n-3 && nums[k] == nums[k+1]) k++;
        }
        return res;
    }
};
```

# 盛最多水的容器

[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

两条垂直的线和X轴组成一个容器，灌水多少不仅与两个柱子的高度有关，也与两个柱子的距离有关，公式：`S(i,j) = min(ai, aj) * (j-i)`，容器不能倾斜，求容纳最多水的两个线组合。定义left和right两个指针分别指向数组的左右两端，然后两个指针向中间搜索，每移动一次算一个值和结果比较取较大的，容器装水量的算法是找出左右两个边缘中较小的那个乘以两边缘的距离。

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0,right = height.size() - 1;
        int res = 0;
        while(left < right)
        {
            int temp = min(height[right],height[left]);
            res = max(res,temp*(right - left));
            if(height[right] < height[left]) right --;
            else left++;
        }
        return res;
    }
};
```

# 合并两个有序数组

[合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

双指针解法，利用了后置 `--` 的运算特性：

```
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		int curr = m-- + n-- - 1;
		while(m>=0 && n >=0)		
			nums1[curr--] = (nums1[m] > nums2[n] ? nums1[m--] : nums2[n--]);	
		
		while(n>=0)
			nums1[curr--] = nums2[n--];				
    }
};
```

# 平方数之和

[平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

```
class Solution {
public:
    bool judgeSquareSum(int c) {
        long left = 0,right = sqrt(c);
        while(left <= right)
        {
            long square = left*left + right*right;
            if(square == c)
                return true;
            else if(square > c)
                right--;
            else    
                left++;            
        }
        return false;
    }
};
```

# 验证回文字符串 Ⅱ

[验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

删除的话，左右都有被删除的机会，所以要一起考虑：

```
class Solution {
public:
    bool validPalindrome(string s) {        
        int left = 0,right = s.length() - 1;
        while(left < right)
        {
            if(s[left] == s[right])
                left++,right--;
            else
                return helper(s,left+1,right) || helper(s,left,right-1);
        }
        return true;
    }

    bool helper(string& s,int low,int high)
    {
        while(low < high)    
            if(s[low++] != s[high--])
                return false;   
        return true;
    } 
};
```

# 通过删除字母匹配到字典里最长单词

[通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

```
class Solution {
public:
    string findLongestWord(string s, vector<string>& d) {
        string best;
        for(auto const & str : d)
        {
            int l1 = best.size(),l2 = str.size();
            if(l1 > l2 || (l1 == l2 && best.compare(str) < 0))
                continue;
            if(isSubstr(s,str))
                best = str;
        }
        return best;
    }

    bool isSubstr(string& s,string str)
    {
        int i = 0,j = 0;
        while(i < s.length() && j < str.length()){
            if(s[i] == str[j])
                j++;
            i++;
        }
        return j == str.length();
    }
};
```

#### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)





