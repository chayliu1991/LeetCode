# [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
		if(s.empty())
			return 0;
		
		int res = INT_MIN;
		int left = 0,right = 0;		
		vector<bool> windows(128,false);
		while(right < s.length())
		{
			char rc = s[right];			
			while(windows[rc])
			{
				char lc = s[left];
				windows[lc] = false;
				left++;
			}
			
			res = max(res,right-left+1);
			windows[rc] = true;
			right++;			
		}
		return res;
    }
};
```

# [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
		if(s.length() < p.length())
			return {};
		
		vector<int> res,needs(128,0),windows(128,0);
		for(char c : p)
			needs[c] ++;
		
		int left = 0,right = 0;
		while(right < s.length())
		{
			char rc = s[right];
			windows[rc] ++;
			while(windows[rc] > needs[rc])
			{
				char lc = s[left];
				windows[lc]--;
				left++;
			}
			
			if(right - left + 1 == p.length())
				res.push_back(left);	
			
			right++;
		}
		return res;
    }
};
```

# [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```
class Solution {
public:
    string minWindow(string s, string t) {
		if(s.length() < t.length())
			return "";
		
		vector<int> needs(128,0),windows(128,0);
		int left = 0,right = 0;
		int matchLen = 0,minLen = INT_MAX;
		string res;			
		for (char c : t)
            ++needs[c];		
		
		while(right < s.length())
		{
			char rc = s[right];
			windows[rc]++;
			
			if(needs[rc] && windows[rc] <= needs[rc])
				matchLen ++;
			while(left <= right && matchLen == t.length())
			{
				if(minLen > right - left + 1)
				{
					minLen = right - left + 1;
					res = s.substr(left,minLen);
				}
				
				char lc = s[left];
				windows[lc]--;
				if(needs[lc] && windows[lc] < needs[lc])
					matchLen--;
				left++;
			}	
            ++right;		
		}
		return res;
	}	
};
```



