# 382. 链表随机节点

[382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

```
class Solution {
	ListNode *head_;
public:
    Solution(ListNode* head) : head_(head){
    }
    int getRandom() {
        int res = head_->val, i = 2;
        ListNode *cur = head_->next;
        while (cur) {
            if (rand() % i++ == 0) 
				res = cur->val;
            cur = cur->next;
        }
        return res;
    }   
};
```

# 384. 打乱数组

[384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)

 ```
class Solution {
    vector<int> _origin;
public:
    Solution(vector<int>& nums) : _origin(std::move(nums)){
    }
    
    vector<int> reset() {
        return _origin;
    }
    
    vector<int> shuffle() {
        if(_origin.empty())
            return {};
        vector<int> shuffled(_origin);
        int n = _origin.size();
        for(int i = n - 1;i >= 0;--i)
            swap(shuffled[i],shuffled[rand() % (i+1)]);
        
        return shuffled;
    }
};
 ```

# 528. 按权重随机选择

[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

可以先使用 `partial_sum` 求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。这里的二分法可以用 `lower_bound` 实现。

```
class Solution {
    vector<int> _sums;
public:
    Solution(vector<int>& w) : _sums(std::move(w)){
        partial_sum(_sums.begin(),_sums.end(),_sums.begin());
    }
    
    int pickIndex() {
        int pos = (rand() % _sums.back()) + 1;
        return lower_bound(_sums.begin(),_sums.end(),pos) - _sums.begin();
    }
};
```

# 398. 随机数索引

[398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

```
class Solution {
public:
    Solution(vector<int> nums): v(nums) {}
    
    int pick(int target) {
        int cnt = 0, res = -1;
        for (int i = 0; i < v.size(); ++i) {
            if (v[i] != target) 
				continue;
            ++cnt;
            if (rand() % cnt == 0) 
				res = i;
        }
        return res;
    }
private:
    vector<int> v;
};
```

# 470. 用 Rand7() 实现 Rand10()

[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

范围在 `1～7` 的随机数产生器，即 `1~7` 各个数字出现的概率皆为 `1/7`。范围在 `1～10` 的随机数产生器，即 `1~10` 各个数字出现的概率皆为 `1/10`。这个题的构造思路是先构造一个 `randN`，这个 `N` 必须是10的整数倍，然后 `randN % 10` 就可以得到了 `rand10`。所以可以从 `rand7` 先构造出 `rand49` ，再把 `rand49` 中大于等于 `40` 的都过滤掉，这样就得到了`rand40`，再对 `10` 取余即可。

```
class Solution {
public:
    int rand10() {
        while (true) {
            int num = (rand7() - 1) * 7 + rand7();
            if (num <= 40) 
                return num % 10 + 1;
        }
    }
};
```

递归：

```
class Solution {
public:
    int rand10() {
        int num = (rand7() - 1) * 7 + rand7();
        return (num <= 40) ? (num % 10 + 1) : rand10();
    }
};
```

# 46. 全排列

[46. 全排列](https://leetcode-cn.com/problems/permutations/)

```
class Solution {
public:
    void backTrace(vector<vector<int>>& res,vector<int>& path,int start,int len)
    {
        //@ 所有的数都填完了
        if(start == len)
        {
            res.push_back(path);
            return;
        }

        for(int i = start;i < len;i++)
        {
            swap(path[i],path[start]);
            backTrace(res,path,start+1,len);
            swap(path[i],path[start]); //@ 撤销操作
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int> > res;
        backTrace(res, nums, 0, (int)nums.size());
        return res;
    }
};
```











