# [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```
class Solution {
public:
    bool isValid(string s) 
    {
        unordered_map<char, char> pairs = {
            { ')', '(' },
            { ']', '[' },
            { '}', '{' }
        };
        stack<char> sk;
        for (const auto c : s)
        {
            
            if (pairs.find(c) != pairs.end())
            {
                if (sk.empty() || sk.top() != pairs[c])
                    return false;
                sk.pop();
            }
            else
                sk.push(c);
        }
        return sk.empty() ? true : false;
    }
};
```

# [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```
class Solution {
public:
    int longestValidParentheses(string s)
    {	
        int res = 0;
        stack<int> sk;
        sk.push(-1);  //@ 无效位置
        for (int i = 0; i < s.length(); i++)
        {
            if (s[i] == '(')
                sk.push(i);
            else
            {
                sk.pop();
                if (sk.empty())
                    sk.push(i); //@ 上一个无效的位置
                else
                    res = max(res, i - sk.top());
            }
        }
        return res;
    }
};
```

# [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

```
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> sk;
        for (const auto token : tokens)
        {
			if(token == "+" || token == "-" || token == "/" || token == "*")
			{
				int second = sk.top(); sk.pop();
                int first = sk.top(); sk.pop();
				if(token == "+")
					sk.push(first+second);
				else if(token == "-")
					sk.push(first-second);
				else if(token == "*")
					sk.push(first*second);
				else 
					sk.push(first/second);
			} 
            else
                sk.push(stoi(token));
        }
        return sk.top();
    }
};
```

# [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

```
class Solution {
public:
    int calculate(string s) {   
        stack<int> sk;
        int num = 0;
        char sign = '+';

        for(int i = 0;i < s.length();i++)
        {
            char curr = s[i];
            if(isdigit(curr))
                num = num * 10 + (curr - '0');
            if((!isdigit(curr) && curr != ' ') || (i == s.length()-1))
            {
                int prev = 0;
                if(sign == '+')
                    sk.push(num);
                else if(sign == '-')
                    sk.push(-num);
                else if(sign == '*')
                {
                    prev = sk.top();sk.pop();
                    sk.push(prev*num);
                }
                else
                {
                    prev = sk.top(),sk.pop();
                    sk.push(prev/num);
                }
                sign = curr; //@ 更新符号
                num = 0;     //@ 数字重置
            }                
        }

        int res = 0;
        while(!sk.empty())
        {
            res += sk.top();
            sk.pop();
        }
        return res;
    }
};
```



# 用栈实现队列

[用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```
class MyQueue {
public:
    stack<int> _SIn,_SOut;
    /** Initialize your data structure here. */
    MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    void push(int x) {
        _SIn.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        if(_SOut.empty())
        {
            while(!_SIn.empty())
            {
                _SOut.push(_SIn.top());
                _SIn.pop();
            }
        }

        int x = _SOut.top();
        _SOut.pop();
        return x; 
    }
    
    /** Get the front element. */
    int peek() {
        int x = this->pop();
        _SOut.push(x);
        return x;
    }
    
    /** Returns whether the queue is empty. */
    bool empty() {
        return _SIn.empty() && _SOut.empty();
    }
};
```

# 用队列实现栈

[用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```
class MyStack {
public:
    queue<int> _QIn,_QOut;
    /** Initialize your data structure here. */
    MyStack() {

    }
    
    /** Push element x onto stack. */
    void push(int x) {
        _QIn.push(x);
    }
    
    /** Removes the element on top of the stack and returns that element. */
    int pop() {
        while(_QIn.size() > 1)
        {
             _QOut.push(_QIn.front());
             _QIn.pop();
        }           
        int x = _QIn.front();
        //@ 复制回去并清空_QOut
        _QIn = _QOut;  
        while(!_QOut.empty())
            _QOut.pop();
        return x;
    }
    
    /** Get the top element. */
    int top() {
        return _QIn.back();
    }
    
    /** Returns whether the stack is empty. */
    bool empty() {
        return _QIn.empty();
    }
};
```

# 包含min函数的栈

[包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

```
class MinStack {
public:
    stack<int> _data,_min;
    /** initialize your data structure here. */
    MinStack() {

    }
    
    void push(int x) {
        _data.push(x);
        if(_min.empty())
            _min.push(x);
        else
        {
            if(x > _min.top())
                _min.push(_min.top());
            else
                _min.push(x);
        }    
    }
    
    void pop() {
        _data.pop();
        _min.pop();
    }
    
    int top() {
        return _data.top();
    }
    
    int min() {
        return _min.top();
    }
};
```







