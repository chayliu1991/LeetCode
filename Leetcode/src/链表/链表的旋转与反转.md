# [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

```
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {     
		if(head == nullptr || head->next == nullptr || k == 0)
			return head;		
		int len = 0;
		for(ListNode* p = head;p;p=p->next)
			len++;
		k %= len;
		if(k == 0)
			return head;
		
		ListNode* fast = head,* slow = head;
		while(k--)
			fast = fast->next;
		while(fast->next)
		{
			slow = slow->next;
			fast = fast->next;
		}
		fast->next = head;
		ListNode* res = slow->next;
		slow->next = nullptr;
		return res;
    }
};
```

# [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr) 
            return head;
        
        ListNode node(-1);
        ListNode* dummy = &node;
        dummy->next = head;

        ListNode* prev = dummy,*curr = head;
        ListNode*left = nullptr,*right = nullptr;
        while(curr && curr->next)
        {
            //@ 记录连续两个节点
            left = curr->next;
            right = curr->next->next;
            //@ 反转相邻的节点
            curr->next->next = curr;
            curr->next = right;
            prev->next = left;
            //@ 向前推进
            prev = curr;
            curr = right;
        }
        return dummy->next;
    }
};
```

# [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;
        ListNode* prev = nullptr,*curr = head;
        while(curr)
        {
            ListNode* tmp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = tmp;
        }
        return prev;
    }
};
```

# [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```

```

# [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```

```

