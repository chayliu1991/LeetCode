# [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {		
		ListNode node(-1);
		ListNode* dummy = &node;
		ListNode* curr = dummy;
		while(l1 && l2)
		{
			if(l2->val < l1->val)
				curr->next = l2,l2 = l2->next;
			else
				curr->next = l1,l1 = l1->next;
			curr = curr->next;
		}			
		curr->next = l1 ? l1 : l2;
		return dummy->next;
    }
};
```

# [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode node1(-1),node2(-1);
		ListNode* hSmall = &node1,*hBig = &node2;
		ListNode* currSmall = hSmall,*currBig = hBig;
		
		while(head)
		{
			if(head->val < x)
				currSmall->next = head, currSmall = currSmall->next;
			else
				currBig->next = head,currBig = currBig->next;
			head = head->next;
		}
		
		//@ 将两个链表拼接起来
		currBig->next = nullptr;
		currSmall->next = hBig->next;
		
		return hSmall->next;
    }
};
```

# 复制带随机指针的链表

[复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

采用 hash 表存储：

```
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr)
			return head;
	
		map<Node*,Node*> dict;
		Node* curr = head,* link = nullptr;
		while(curr)
		{
			dict[curr] = new Node(curr->val);
			curr = curr->next;		
		}

		curr = head;
		while(curr)
		{
			dict[curr]->next = dict[curr->next];
			dict[curr]->random = dict[curr->random];
			curr = curr->next;
		}
		return dict[head];
    }
};
```

创建链表的副本，并分离出来：

```
class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (head == nullptr)  return head;
        //@ 复制节点，遍历链表，在当前节点后插入副本节点
        Node* curr = head;
        while(curr)
        {
            Node *node = new Node(curr->val);
            Node *next = curr->next;
            node->next = next;
            curr->next = node;
            curr = next;
        }

        //@ 对副本节点设置random指针
        curr = head;
        while(curr)
        {                                                                          
            curr->next->random = curr->random ? curr->random->next : nullptr;
            curr = curr->next->next;
        }

        //@ 分离出原链表和副本链表
        curr = head;
        Node* new_head = head->next; //@ 副本链表的头节点
        Node* new_tail = new_head;   //@ 副本链表的尾节点
        while(curr)
        {
            curr->next = curr->next->next;
            curr = curr->next;

            new_tail->next = curr ? curr->next : nullptr;
            new_tail = new_tail->next;
        }
        return new_head;
    }
};
```

# 奇偶链表

[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == nullptr) 
            return nullptr;
        ListNode* odd = head,*even = head->next,*evenStart = even;
        //@ 分别串联奇数和偶数位序的节点
        while(even && even->next)
        {
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenStart;
        return head;
    }
};
```

# 回文链表

[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

使用快慢指针找到链表的中间节点，将链表分成两部分，并且反转后半部分，依次比较值：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr || head->next == nullptr) 
            return true;  //@ 空链表和单节点链表是回文链表
        ListNode* slow = head,*fast= head;
        //@ 快慢指针找到链表的中点
        for(;fast && fast->next;fast = fast->next->next,slow = slow->next);    
        ListNode* curr = slow,*next = nullptr,*pre = nullptr;
        //@ 翻转后半部分链表
        for(;curr;next = curr->next,curr->next = pre,pre = curr,curr = next);
        //@ 依次比较两个链表的对应元素
        for(ListNode* front=head,* back = pre;front && back;front = front->next,back = back->next)
            if(front->val != back->val) return false;
        return true;
    }
};
```

利用 `vector` 存储：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> store;
        ListNode* curr = head;
        while(curr != nullptr){
            store.push_back(curr->val);
            curr = curr->next;
        }
           
        int front = 0,back = store.size() - 1;
        while(front < back)
        {
            if(store[front] != store[back])
                return false;
            front++,back--;
        }
        return true;
    }
};
```

# 排序链表

[排序链表](https://leetcode-cn.com/problems/sort-list/)

归并排序：

```
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *slow = head,*fast = head->next;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode *mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head),sortList(mid)); 
    }

    ListNode* merge(ListNode* l1,ListNode* l2)
    {
        ListNode dummy(-1);
        ListNode* tail = &dummy;
        while(l1 && l2){
            if(l1->val > l2->val)
                swap(l1,l2);
            tail->next = l1;
            l1 = l1->next;
            tail = tail->next;
        }
        if(l1) tail->next = l1;
        if(l2) tail->next = l2;
        return dummy.next;
    }

};
```


