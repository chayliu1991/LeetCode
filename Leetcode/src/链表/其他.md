# [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		ListNode* dummy = new ListNode(-1),*node = dummy;
		while(l1 && l2){
			if(l1->val < l2->val){
                node->next = l1;
                l1 = l1->next;
            }
            else{
                node->next = l2;
                l2 = l2->next;
            } 
			node = node->next;
		}		
		node->next = l1 ? l1 : l2;
		return dummy->next;
    }
};
```

# 两两交换链表中的节点

[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;

        ListNode* prev = dummy,*curr = head,*left = nullptr,*right = nullptr;
        while(curr && curr->next)
        {
            //@ 记录连续两个节点
            left = curr->next;
            right = curr->next->next;
            //@ 反转相邻的节点
            curr->next->next = curr;
            curr->next = right;
            prev->next = left;
            //@ 向前推进
            prev = curr;
            curr = right;
        }
        return dummy->next;
    }
};
```

# 分隔链表

[分隔链表](https://leetcode-cn.com/problems/partition-list/)

使用两个指针，分别记录小于指定值的节点和大于指定值的节点，然后串联起来：

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smaller = new ListNode(-1); //@ 记录比x小的节点组成的链表
        ListNode *bigger = new ListNode(-1); //@ 记录比x大的节点组成的链表
        ListNode *p1 = smaller,*p2 = bigger;
        while(head)
        {
            if(head->val < x){
                p1->next = head;
                p1 = head;
            }else{
                p2->next = head;
                p2 = head;
            }
            head = head->next; //@ 遍历链表
        }

        //@ 将两个链表拼接起来
        p2->next = nullptr;
        p1->next = bigger->next;
        return smaller->next;
    }
};
```

# 复制带随机指针的链表

[复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

采用 hash 表存储：

```
class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (head == nullptr)  return head;
        unordered_map<Node*, Node*> map; //@ <原链表节点，对应位置的新链表节点>
        Node* curr = head;
        while (curr)
        {
            map[curr] = new Node(curr->val);
            curr = curr->next;
        }

        //@ 遍历原链表 根据map链接新链表
        curr = head;
        while (curr)
        {
            Node* node = map[curr];
            node->next = map[curr->next];
            node->random = map[curr->random];
            curr = curr->next;
        }
        return map[head];
    }
};
```

创建链表的副本，并分离出来：

```
class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (head == nullptr)  return head;
        //@ 复制节点，遍历链表，在当前节点后插入副本节点
        Node* curr = head;
        while(curr)
        {
            Node *node = new Node(curr->val);
            Node *next = curr->next;
            node->next = next;
            curr->next = node;
            curr = next;
        }

        //@ 对副本节点设置random指针
        curr = head;
        while(curr)
        {                                                                          
            curr->next->random = curr->random ? curr->random->next : nullptr;
            curr = curr->next->next;
        }

        //@ 分离出原链表和副本链表
        curr = head;
        Node* new_head = head->next; //@ 副本链表的头节点
        Node* new_tail = new_head;   //@ 副本链表的尾节点
        while(curr)
        {
            curr->next = curr->next->next;
            curr = curr->next;

            new_tail->next = curr ? curr->next : nullptr;
            new_tail = new_tail->next;
        }
        return new_head;
    }
};
```

# 奇偶链表

[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == nullptr) 
            return nullptr;
        ListNode* odd = head,*even = head->next,*evenStart = even;
        //@ 分别串联奇数和偶数位序的节点
        while(even && even->next)
        {
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenStart;
        return head;
    }
};
```

# 回文链表

[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

使用快慢指针找到链表的中间节点，将链表分成两部分，并且反转后半部分，依次比较值：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr || head->next == nullptr) 
            return true;  //@ 空链表和单节点链表是回文链表
        ListNode* slow = head,*fast= head;
        //@ 快慢指针找到链表的中点
        for(;fast && fast->next;fast = fast->next->next,slow = slow->next);    
        ListNode* curr = slow,*next = nullptr,*pre = nullptr;
        //@ 翻转后半部分链表
        for(;curr;next = curr->next,curr->next = pre,pre = curr,curr = next);
        //@ 依次比较两个链表的对应元素
        for(ListNode* front=head,* back = pre;front && back;front = front->next,back = back->next)
            if(front->val != back->val) return false;
        return true;
    }
};
```

利用 `vector` 存储：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> store;
        ListNode* curr = head;
        while(curr != nullptr){
            store.push_back(curr->val);
            curr = curr->next;
        }
           
        int front = 0,back = store.size() - 1;
        while(front < back)
        {
            if(store[front] != store[back])
                return false;
            front++,back--;
        }
        return true;
    }
};
```

# 排序链表

[排序链表](https://leetcode-cn.com/problems/sort-list/)

归并排序：

```
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *slow = head,*fast = head->next;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode *mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head),sortList(mid)); 
    }

    ListNode* merge(ListNode* l1,ListNode* l2)
    {
        ListNode dummy(-1);
        ListNode* tail = &dummy;
        while(l1 && l2){
            if(l1->val > l2->val)
                swap(l1,l2);
            tail->next = l1;
            l1 = l1->next;
            tail = tail->next;
        }
        if(l1) tail->next = l1;
        if(l2) tail->next = l2;
        return dummy.next;
    }

};
```


