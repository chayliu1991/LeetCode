

# 反转链表 II

[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

找到反转链表的

```
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode* dummy=new ListNode(-1);
		dummy->next = head;
        ListNode* begining = dummy;  //@ 初始化为 dummy，处理head==nullptr
		
        int change_len = n - m + 1; //@ 一共需要反转的节点个数，m==n时，反转自身
		//@ 移动到第m-1个节点，记录前一个节点
		ListNode* curr = head;
		while(curr && --m)
		{
			begining  = curr;
			curr = curr->next;
		}
		
		ListNode* ending = curr;   //@ 反转后的链表尾节点，就是当前的节点 
		ListNode* pre = nullptr;  //@ 反转后的链表头节点	
		while(curr && change_len)
		{
			ListNode* next = curr->next;
			curr->next = pre;
			pre = curr;
			curr = next;
			
			change_len--;			
		}	
		
		begining->next = pre;  //@ 连接反转后链表的头节点
		ending->next = curr;   //@ 连接反转后链表的尾巴节点		
		
        return dummy->next;
    }
};
```

# 相交链表

[相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

集合求交集的思路：

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set<ListNode*> hash;
        ListNode * curr = headA;
        while(curr)
        {
            hash.insert(curr);
            curr = curr->next;
        }

        curr = headB;
        while(curr)
        {
            if(hash.find(curr) != hash.end())
                return curr;
            
            curr = curr->next;
        }
        return nullptr;
    }
};
```

如果两个链表相交应该呈现“Y”字型，让较长的链表先走长度差，然后一起向前走：

```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = get_list_length(headA),lenB = get_list_length(headB);   
        if(lenA > lenB)
            headA = forward_long_list(lenA,lenB,headA);
        else
            headB = forward_long_list(lenB,lenA,headB);
        
        while(headA && headB)
        {
            if(headA == headB)
                return headA;
            headA = headA->next;
            headB = headB->next;
        }
        return nullptr;        
    }

    int get_list_length(ListNode *head)
    {
        ListNode *curr = head;
        int len = 0;
        while(curr){
            curr = curr->next;
            ++len;
        }
        return len;
    }

    ListNode * forward_long_list(int long_len,int short_len,ListNode *head)
    {
        int diff = long_len - short_len;
        while(head && diff)
        {
            head = head->next;
            diff--;
        }
        return head;
    }
};
```

# 合并两个有序链表

[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

非递归解法：

```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		ListNode* dummy = new ListNode(-1),*node = dummy;
		while(l1 && l2){
			if(l1->val < l2->val){
                node->next = l1;
                l1 = l1->next;
            }
            else{
                node->next = l2;
                l2 = l2->next;
            } 
			node = node->next;
		}		
		node->next = l1 ? l1 : l2;
		return dummy->next;
    }
};
```

递归解法：

```
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		if(l2 == nullptr) return l1;
        if(l1 == nullptr) return l2;

        if(l1->val > l2->val)
        {
            l2->next = mergeTwoLists(l1,l2->next);
            return l2;
        }
        l1->next = mergeTwoLists(l1->next,l2);
        return l1;
    }
};
```

# 两两交换链表中的节点

[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;

        ListNode* prev = dummy,*curr = head,*left = nullptr,*right = nullptr;
        while(curr && curr->next)
        {
            //@ 记录连续两个节点
            left = curr->next;
            right = curr->next->next;
            //@ 反转相邻的节点
            curr->next->next = curr;
            curr->next = right;
            prev->next = left;
            //@ 向前推进
            prev = curr;
            curr = right;
        }
        return dummy->next;
    }
};
```

# 分隔链表

[分隔链表](https://leetcode-cn.com/problems/partition-list/)

使用两个指针，分别记录小于指定值的节点和大于指定值的节点，然后串联起来：

```
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smaller = new ListNode(-1); //@ 记录比x小的节点组成的链表
        ListNode *bigger = new ListNode(-1); //@ 记录比x大的节点组成的链表
        ListNode *p1 = smaller,*p2 = bigger;
        while(head)
        {
            if(head->val < x){
                p1->next = head;
                p1 = head;
            }else{
                p2->next = head;
                p2 = head;
            }
            head = head->next; //@ 遍历链表
        }

        //@ 将两个链表拼接起来
        p2->next = nullptr;
        p1->next = bigger->next;
        return smaller->next;
    }
};
```

# 复制带随机指针的链表

[复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

采用 hash 表存储：

```
class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (head == nullptr)  return head;
        unordered_map<Node*, Node*> map; //@ <原链表节点，对应位置的新链表节点>
        Node* curr = head;
        while (curr)
        {
            map[curr] = new Node(curr->val);
            curr = curr->next;
        }

        //@ 遍历原链表 根据map链接新链表
        curr = head;
        while (curr)
        {
            Node* node = map[curr];
            node->next = map[curr->next];
            node->random = map[curr->random];
            curr = curr->next;
        }
        return map[head];
    }
};
```

创建链表的副本，并分离出来：

```
class Solution {
public:
    Node* copyRandomList(Node* head)
    {
        if (head == nullptr)  return head;
        //@ 复制节点，遍历链表，在当前节点后插入副本节点
        Node* curr = head;
        while(curr)
        {
            Node *node = new Node(curr->val);
            Node *next = curr->next;
            node->next = next;
            curr->next = node;
            curr = next;
        }

        //@ 对副本节点设置random指针
        curr = head;
        while(curr)
        {                                                                          
            curr->next->random = curr->random ? curr->random->next : nullptr;
            curr = curr->next->next;
        }

        //@ 分离出原链表和副本链表
        curr = head;
        Node* new_head = head->next; //@ 副本链表的头节点
        Node* new_tail = new_head;   //@ 副本链表的尾节点
        while(curr)
        {
            curr->next = curr->next->next;
            curr = curr->next;

            new_tail->next = curr ? curr->next : nullptr;
            new_tail = new_tail->next;
        }
        return new_head;
    }
};
```

# 奇偶链表

[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

```
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head == nullptr) 
            return nullptr;
        ListNode* odd = head,*even = head->next,*evenStart = even;
        //@ 分别串联奇数和偶数位序的节点
        while(even && even->next)
        {
            odd->next = even->next;
            odd = odd->next;
            even->next = odd->next;
            even = even->next;
        }
        odd->next = evenStart;
        return head;
    }
};
```

# 回文链表

[回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

使用快慢指针找到链表的中间节点，将链表分成两部分，并且反转后半部分，依次比较值：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr || head->next == nullptr) 
            return true;  //@ 空链表和单节点链表是回文链表
        ListNode* slow = head,*fast= head;
        //@ 快慢指针找到链表的中点
        for(;fast && fast->next;fast = fast->next->next,slow = slow->next);    
        ListNode* curr = slow,*next = nullptr,*pre = nullptr;
        //@ 翻转后半部分链表
        for(;curr;next = curr->next,curr->next = pre,pre = curr,curr = next);
        //@ 依次比较两个链表的对应元素
        for(ListNode* front=head,* back = pre;front && back;front = front->next,back = back->next)
            if(front->val != back->val) return false;
        return true;
    }
};
```

利用 `vector` 存储：

```
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        vector<int> store;
        ListNode* curr = head;
        while(curr != nullptr){
            store.push_back(curr->val);
            curr = curr->next;
        }
           
        int front = 0,back = store.size() - 1;
        while(front < back)
        {
            if(store[front] != store[back])
                return false;
            front++,back--;
        }
        return true;
    }
};
```

# 排序链表

[排序链表](https://leetcode-cn.com/problems/sort-list/)

归并排序：

```
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *slow = head,*fast = head->next;
        while(fast && fast->next){
            slow = slow->next;
            fast = fast->next->next;
        }

        ListNode *mid = slow->next;
        slow->next = nullptr;
        return merge(sortList(head),sortList(mid)); 
    }

    ListNode* merge(ListNode* l1,ListNode* l2)
    {
        ListNode dummy(-1);
        ListNode* tail = &dummy;
        while(l1 && l2){
            if(l1->val > l2->val)
                swap(l1,l2);
            tail->next = l1;
            l1 = l1->next;
            tail = tail->next;
        }
        if(l1) tail->next = l1;
        if(l2) tail->next = l2;
        return dummy.next;
    }

};
```


