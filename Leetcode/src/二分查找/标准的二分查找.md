# 标准的二分查找

```
class BinarySearch
{
public:
	int search(vector<int> nums, int target)
	{
		int left = 0, right = nums.size() - 1;
		while (left <= right)
		{
			int mid = left + ((right - left) >> 1);
			if (nums[mid] == target)
				return mid;
			else if (nums[mid] > target)
				right = mid - 1;
			else
				left = mid + 1;
		}
		return -1;
	}
};
```

注意：

- 因为循环条件中存在 `left == right` 的情况，因此每次必须改变 `left` 和 `right` 的指向，以防止进入死循环
- 求 `mid`  时，不采用  `(right + left) >>  1`，为了防止 `right + left` 溢出
- `left + ((right - left) >> 1)` ，对于目标区间长度为奇数而言，是处于正中间的节点，对于长度为偶数而言，是中间偏左的节点，当区间长度小于等于2时，`mid` 和 `left` 节点总是在同一侧，因此左右边界相遇时，只有下面两种情况：
  - `left` 和 `mid` 指向同一个数，`right` 指向下一个数
  - `left`，`mid`，`right` 指向同一个数

# 374. 猜数字大小

[374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

```
class Solution {
public:
    int guessNumber(int n) {
		int left = 1,right = n;
		while(left <= right)
		{
			int mid = left + ((right - left) >> 1);
			if(guess(mid) == 0)
				return mid;
			else if(guess(mid) == -1)
				right = mid - 1;
			else
				left = mid + 1;
		}
        return -1;
    }
};
```

# 69. x 的平方根

[69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

暴力递归：

```
class Solution {
public:
    int mySqrt(int x) {      
        int k = 1;
        while(x / k >= k) 
            ++k;                           
        return k-1;
    }
};
```

二分查找：

```
class Solution {
public:
    int mySqrt(int x) {
        if(x <= 1)
            return x;  //@ 防止除以0
        
        //@ 右边界没有必要那么大
        int left = 1,right = (x >> 1) + 1;
        while(left <= right)
        {
            int mid = left + ((right - left) >> 1);
            //@ 使用除法是为了防止乘法越界
            if(mid > x / mid)
                right = mid - 1;
            else if(mid < x / mid)
            {
                if((mid+1) > x / (mid+1))
                    return mid;
                left = mid + 1;
            }
            else    
                return mid;
        }
        return -1;
    }
};
```

# 33. 搜索旋转排序数组

[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0,right = nums.size() - 1;
        while(left <= right)
        {
            int mid = left + ((right - left) >> 1);
            if(nums[mid] == target)
                return mid;

            if(nums[left] <= nums[mid])     //@ 左边是有序的
            {
                if(target >= nums[left] && target < nums[mid])
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else    //@ 右边是有序的
            {
                if(target <= nums[right] && target > nums[mid])
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
};
```

# 81. 搜索旋转排序数组 II

[81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```
class Solution {
public:
    bool search(vector<int>& nums, int target) {
		int left = 0,right = nums.size() - 1;
		while(left <= right)
		{
			int mid = left + ((right - left) >> 1);
			if(nums[mid] == target)
				return true;
			
			if(nums[left] < nums[mid])
			{
				if(target < nums[mid] && target >= nums[left])
					right = mid - 1;
				else
					left = mid + 1;					
			}
			else if(nums[mid] < nums[right])
			{
				if(target <= nums[right] && target > nums[mid])
					left = mid + 1;
				else
					right = mid - 1;
			}
			else
			{
				while(left <= right && nums[left] == nums[mid])
					left ++;
				while(left <= right && nums[right] == nums[mid])
					right --;
			}				
		}
        return false;
    }
};
```

# 4. 寻找两个正序数组的中位数

[4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size(), left = (m + n + 1) / 2, right = (m + n + 2) / 2;
        return (findKth(nums1, 0, nums2, 0, left) + findKth(nums1, 0, nums2, 0, right)) / 2.0;
    }
    int findKth(vector<int>& nums1, int start1, vector<int>& nums2, int start2, int k) {
        if (start1 >= nums1.size()) return nums2[start2 + k - 1];
        if (start2 >= nums2.size()) return nums1[start1 + k - 1];
        if (k == 1) return min(nums1[start1], nums2[start2]);
        int midVal1 = (start1 + k / 2 - 1 < nums1.size()) ? nums1[start1 + k / 2 - 1] : INT_MAX;
        int midVal2 = (start2 + k / 2 - 1 < nums2.size()) ? nums2[start2 + k / 2 - 1] : INT_MAX;
        if (midVal1 < midVal2) {
            return findKth(nums1, start1 + k / 2, nums2, start2, k - k / 2);
        } else {
            return findKth(nums1, start1, nums2, start2 + k / 2, k - k / 2);
        }
    }
};
```

