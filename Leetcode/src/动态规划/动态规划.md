# 简单问题

## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2)
            return n;
        int pre2 = 1,pre1 = 2,res;
        for(int i = 2;i < n;i++)
        {
            res = pre1 + pre2;
            pre2 = pre1;
            pre1 = res; 
        }
        return res;
    }
};
```

# 一维数组

## [413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

```
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& A) {
        size_t n = A.size();
        if(n < 3)
            return 0;
        
        vector<int> dp(n,0);
        for(int i = 2;i < n;i++)
        {
            if(A[i-1] - A[i-2] == A[i] - A[i-1])
                dp[i] = dp[i-1] + 1;
        }
        return std::accumulate(dp.begin(),dp.end(),0);
    }
};
```

# 二维数组

## [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        int m = grid.size(), n = grid[0].size();  
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0] = grid[0][0];        

        for(int i = 1;i < n;i++)
            dp[0][i] = dp[0][i-1] + grid[0][i];
			
        for(int j = 1;j < m;j++)
            dp[j][0] = dp[j-1][0] + grid[j][0];

        for(int i = 1;i < m;i++)
        {
            for(int j = 1;j < n;j++)
            {
                dp[i][j] = std::min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        return dp.back().back();
    }   
};
```

状态空间压缩：

对于第 `i` 行，在遍历到第 `j` 列的时候，因为第 `j-1` 列已经更新过了，所以 `dp[j-1]` 代表 `dp[i][j-1]`的值；而 `dp[j]` 待更新，当前存储的值是在第 `i-1` 行的时候计算的，所以代表 `dp[i-1][j]` 的值。 

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        int m = grid.size(), n = grid[0].size();  
        vector<int> dp(n,0);
        dp[0] = grid[0][0];      
        for(int i = 1;i < n;i++)
            dp[i] = dp[i-1] + grid[0][i];

        for(int i = 1;i < m;i++)
        {
            for(int j = 0;j < n;j++)
            {
                if(j == 0)
                    dp[j] += grid[i][0];
                else
                    dp[j] = std::min(dp[j-1],dp[j]) + grid[i][j];
            }
        }
        return dp.back();
    }
};
```

## [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

```
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return {};
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX-1));
        for(int i = 0;i < m;i++)
        {
            for(int j = 0;j < n;j++)
            {
                if(matrix[i][j] == 0)
                {
                    dp[i][j] = 0;
                    continue;
                }
                if(i > 0)
                    dp[i][j] = std::min(dp[i-1][j] + 1,dp[i][j]);
                if(j > 0)
                    dp[i][j] = std::min(dp[i][j-1] + 1,dp[i][j]);     
            }
        }

        for(int i = m - 1;i >= 0;--i)
        {
            for(int j = n -1;j >= 0;--j)
            {
                if(matrix[i][j] == 0)
                {
                    dp[i][j] = 0;
                    continue;
                }
                if(i < m -1)
                    dp[i][j] = std::min(dp[i+1][j] + 1,dp[i][j]);
                if(j < n-1)
                    dp[i][j] = std::min(dp[i][j+1] + 1,dp[i][j]);               
            }
        }
        return dp;
    }
};
```

## [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        int m = matrix.size(),n = matrix[0].size(),max_side = 0;
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i = 1;i <= m;i++)
        {
            for(int j = 1;j <= n;j++)
            {
                if(matrix[i-1][j-1] == '1')
                    dp[i][j] = std::min(dp[i-1][j-1],std::min(dp[i][j-1],dp[i-1][j])) + 1;
                max_side = std::max(max_side,dp[i][j]);
            }           
        }
        return max_side * max_side;
    }
};
```

#  分割问题

## [279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```
class Solution {
public:
    int numSquares(int n) {
        if(n <= 0)
            return 0;
        vector<int> dp(n+1,INT_MAX);
        dp[0] = 0;
        for(int i = 1;i <= n;++i)
        {
            for(int j = 1;j * j <= i;++j)
                dp[i] = min(dp[i],dp[i-j*j] + 1);
        }
        return dp[n];
    }
};
```

## [91. 解码方法](https://leetcode-cn.com/problems/decode-ways/)

```
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        if(n == 0 ||  s[0] == '0')
            return 0;
        vector<int> dp(n+1,0);
        dp[0] = 1,dp[1] = 1;
        for(int i = 1;i < n;++i)
        {
            if(s[i] == '0')
            {
                if(s[i-1] == '1' || s[i-1] == '2')
                    dp[i+1] = dp[i-1];
                else
                    return 0;
            }
            else
            {
                if(s[i-1] == '1' || (s[i-1] == '2' && s[i] <= '6'))
                    dp[i+1] = dp[i] + dp[i-1];
                else
                    dp[i+1] = dp[i];
            }
        }
        return dp.back();
    }
};
```

## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)











