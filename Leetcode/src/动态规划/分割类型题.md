对于分割类型的题目，动态规划的状态转移方程通常不依赖于相邻的位置，而是依赖于满足分割条件的位置。

# 完全平方数

[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```
class Solution {
public:
    int numSquares(int n) {
        if(n <= 0) return 0; 
        vector<int> dp(n+1,INT_MAX);
        dp[0] = 0;
        for(int i=1;i<=n;++i)
            for(int j=1;j*j<=i;++j)
                dp[i] = min(dp[i],dp[i-j*j]+1);
        return dp.back();
    }
};
```

# 解码方法

[解码方法](https://leetcode-cn.com/problems/decode-ways/)

```
class Solution {
public:
    int numDecodings(string s) {
        if (s.empty() || s[0] == '0') 
            return 0;

        vector<int> dp(s.size()+1);
        dp[0]=1;dp[1]=1;
        for (int i =1; i < s.size(); i++) {
            if (s[i] == '0')
            {
                if (s[i - 1] == '1' || s[i - 1] == '2') 
                    dp[i+1] = dp[i-1];
                else 
                    return 0;
            }  
            else 
            {   
                if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] <= '6'))
                    dp[i+1] = dp[i]+dp[i-1];
                else
                    dp[i+1] = dp[i];
            }
        }
        return dp.back();
    }
};
```

# 单词拆分

[单词拆分](https://leetcode-cn.com/problems/word-break/)

```
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        if(s.empty()) return false;
        int n = s.length();
        //@ 每个位置是否可以被切割
        vector<bool> dp(n+1,false);
        dp[0] = true;
        for(int i=1;i<=n;++i)
        {
            for(auto& word : wordDict)
            {
                int len = word.length();
                if(i >= len && s.substr(i-len,len)== word)
                    dp[i] = dp[i] || dp[i-len];
            }
        }
        return dp.back();
    }
};
```