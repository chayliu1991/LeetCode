# 三角形最小路径和

[三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

动态规划基本思路：分析每行的结果，可以得到如下的状态转移关系：
$$
f[i][j]=\left\{\begin{array}{ll}
f[i-1][0]+c[i][0], & j=0 \\
f[i-1][i-1]+c[i][i], & j=i \\
\min (f[i-1][j-1], f[i-1][j])+c[i][j], & \text { otherwise }
\end{array}\right.
$$
其中，`i` 表示行，`j` 表示列。这里需要注意的是：

- 第 `i` 行共有 `i+1` 个元素
- 对于每一行的第一个元素和最后元素状态转移需要特别处理
- 边界条件是：

$$
f[0][0]=c[0][0]
$$

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
		if(triangle.empty() || triangle[0].empty())
			return 0;
		
        size_t n = triangle.size();
		vector<vector<int>> dp(n,vector<int>(n));          

		dp[0][0] = triangle[0][0];
		for(int i=1;i<n;i++)
		{
            dp[i][0] = dp[i-1][0] + triangle[i][0];
            for(int j=1;j<i;j++)
                dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j];
            dp[i][i] = dp[i-1][i-1] + triangle[i][i];
		}		
		return *std::min_element(dp[n-1].begin(),dp[n-1].end());
	}
};
```

- 时间复杂度：O(n^2)，n 是矩阵的行数
- 空间复杂度：O(n^2)，n 是矩阵的行数

动态规划空间优化：从状态转移关系中可以看出，第 `i` 行的结果只与 `i-1` 有关，因此没有必要保留那么多不必要的结果，可以采用两行(奇偶行)矩阵记录结果，交替进行。

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> dp(2, vector<int>(n));
        dp[0][0] = triangle[0][0];
        for (int i = 1; i < n; ++i) {
            int curr = i & 1,prev = 1 - curr;
            dp[curr][0] = dp[prev][0] + triangle[i][0];
            for(int j=1;j<i;j++)
                dp[curr][j] = min(dp[prev][j-1],dp[prev][j]) + triangle[i][j];
            dp[curr][i] = dp[prev][i-1] + triangle[i][i];
        }
        return *min_element(dp[(n - 1) & 1].begin(), dp[(n - 1) & 1].end());
    }
};
```

- 时间复杂度：O(n^2)，n 是矩阵的行数
- 空间复杂度：O(n)，n 是矩阵的行数

动态规划自底向上，空间优化：根据上面的基础，状态转移自底向上进行，并且使用一维的 dp 记录每行的每个节点的最小值：

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<int> dp(triangle[n-1].begin(),triangle[n-1].end()); //@ 使用最后一行初始化dp数组

        for(int i = n - 2;i >= 0;--i)
        {
            for(int j=0;j<triangle[i].size();++j)            
                dp[j] = min(dp[j], dp[j+1]) + triangle[i][j];            
        }
        return dp[0];
    }
};
```

- 时间复杂度：O(n^2)，n 是矩阵的行数
- 空间复杂度：O(n)，n 是矩阵的行数

动态规划自底向上，原地操作：如果允许原地操作，则：

```
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();   
        for(int i = n- 2;i >= 0;--i)
        {
            for(int j=0;j<triangle[i].size();++j)            
                triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);            
        }
        return triangle[0][0];
    }
};
```
# 不同路径I

[不同路径I](https://leetcode-cn.com/problems/unique-paths/)

```
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);  //@ 存储每一行的结果

        for(int i = 1; i < m; ++i) 
            for(int j = 1; j < n; ++j) 
                dp[j] += dp[j-1];
        return dp.back();
    }
};
```

# 不同路径II

[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		if(obstacleGrid.empty() || obstacleGrid[0].empty())
			return 0;
		
		int m = obstacleGrid.size(),n = obstacleGrid[0].size();
        vector<int> dp(n,0);
		dp[0] = (obstacleGrid[0][0] == 0);
		
		for(int i=0;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(obstacleGrid[i][j] == 1)
				{
					dp[j] = 0;
					continue;
				}
					
				if(j-1 >= 0 && obstacleGrid[i][j-1] == 0)
					dp[j] += dp[j-1];
			}
		return dp.back();
    }
};
```

# 礼物的最大价值

[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

```
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
		if(grid.empty() || grid[0].empty())
			return 0;
		
		int m = grid.size(),n = grid[0].size();
		vector<int> dp(n,0);	
		dp[0] = grid[0][0];
		for(int j =1;j<n;++j)
			dp[j] = dp[j-1] + grid[0][j];
		
		for(int i=1;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(j == 0)
					dp[j] += grid[i][0];
				else
					dp[j] = max(dp[j],dp[j-1]) + grid[i][j];
            }
		return dp.back();
    }
    
};
```

# 01 矩阵

[ 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

题目涉及上下左右四个方向，两遍动态搜索，第一遍：从左上到右下，第二遍，从右下到左上。

```
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = 0; j < matrix[0].size(); ++j) {
                if (matrix[i][j] == 0) continue;
                int up = i == 0 ? 10001 : dp[i-1][j] + 1;
                int left = j == 0 ? 10001 : dp[i][j-1] + 1;
                dp[i][j] = min(up, left);
            }
        }
        for (int i = matrix.size()-1; i >= 0; --i) {
            for (int j = matrix[0].size()-1; j >= 0; --j) {
                if (matrix[i][j] == 0) continue;
                int down = i == matrix.size()-1 ? 10001 : dp[i+1][j] + 1;
                int right = j == matrix[0].size()-1 ? 10001 : dp[i][j+1] +1;
                dp[i][j] = min(dp[i][j], min(down, right));
            }
        }
        return dp;
    }
};
```

# 最大正方形

[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        int m = matrix.size(),n = matrix[0].size(),max_side = 0;
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i=1;i<=m;++i)
            for(int j=1;j<=n;++j){
                if(matrix[i-1][j-1] == '1')
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j])) + 1;
                 max_side = max(max_side,dp[i][j]);
            }         
        return max_side * max_side;
    }
};
```

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)