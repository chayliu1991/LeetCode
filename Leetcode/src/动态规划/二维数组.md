# [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if(grid.empty() || grid[0].empty())
            return 0;
        size_t m = grid.size(), n = grid[0].size();  
        vector<vector<int>> dp(m,vector<int>(n,0));
        dp[0][0] = grid[0][0];        

        for(size_t i = 1;i < n;i++)
            dp[0][i] = dp[0][i-1] + grid[0][i];
			
        for(size_t j = 1;j < m;j++)
            dp[j][0] = dp[j-1][0] + grid[j][0];

        for(size_t i = 1;i < m;i++)
        {
            for(size_t j = 1;j < n;j++)
            {
                dp[i][j] = std::min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        return dp.back().back();
    }   
};
```

状态空间压缩：

对于第 `i` 行，在遍历到第 `j` 列的时候，因为第 `j-1` 列已经更新过了，所以 `dp[j-1]` 代表 `dp[i][j-1]`的值；而 `dp[j]` 待更新，当前存储的值是在第 `i-1` 行的时候计算的，所以代表 `dp[i-1][j]` 的值。 

```
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
         if(grid.empty() || grid[0].empty())
            return 0;
        size_t m = grid.size(), n = grid[0].size();  
        vector<int> dp(n,0);
        dp[0] = grid[0][0];      
        for(size_t i = 1;i < n;i++)
            dp[i] = dp[i-1] + grid[0][i];

        for(size_t i = 1;i < m;i++)
        {
            for(size_t j = 0;j < n;j++)
            {
                if(j == 0)
                    dp[j] += grid[i][0];
                else
                    dp[j] = std::min(dp[j-1],dp[j]) + grid[i][j];
            }
        }
        return dp.back();
    }
};
```



# 120 三角形最小路径和

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

状态转移自底向上进行，并且使用一维的 dp 记录每行的每个节点的最小值：

```
class Solution
{
public:
    int minimumTotal(vector<vector<int>> &triangle)
    {
        if (triangle.empty() || triangle[0].empty())
            return 0;
        int rows = triangle.size();
        vector<int> dp(triangle[rows-1].begin(),triangle[rows-1].end());

        for (int i = rows - 2; i >= 0; i--)
        {
            for (int j = 0; j < triangle[i].size(); j++)
            {
                dp[j] = min(dp[j],dp[j+1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
```

# 不同路径I

[不同路径I](https://leetcode-cn.com/problems/unique-paths/)

```
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);  //@ 存储每一行的结果

        for(int i = 1; i < m; ++i) 
            for(int j = 1; j < n; ++j) 
                dp[j] += dp[j-1];
        return dp.back();
    }
};
```

# 不同路径II

[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		if(obstacleGrid.empty() || obstacleGrid[0].empty())
			return 0;
		
		int m = obstacleGrid.size(),n = obstacleGrid[0].size();
        vector<int> dp(n,0);
		dp[0] = (obstacleGrid[0][0] == 0);
		
		for(int i=0;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(obstacleGrid[i][j] == 1)
				{
					dp[j] = 0;
					continue;
				}
					
				if(j-1 >= 0 && obstacleGrid[i][j-1] == 0)
					dp[j] += dp[j-1];
			}
		return dp.back();
    }
};
```

# 礼物的最大价值

[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

```
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
		if(grid.empty() || grid[0].empty())
			return 0;
		
		int m = grid.size(),n = grid[0].size();
		vector<int> dp(n,0);	
		dp[0] = grid[0][0];
		for(int j =1;j<n;++j)
			dp[j] = dp[j-1] + grid[0][j];
		
		for(int i=1;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(j == 0)
					dp[j] += grid[i][0];
				else
					dp[j] = max(dp[j],dp[j-1]) + grid[i][j];
            }
		return dp.back();
    }
    
};
```

# [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

```
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return {};
        int m = matrix.size(), n = matrix[0].size();
        vector<vector<int>> dp(m,vector<int>(n,INT_MAX-1));
        for(int i = 0;i < m;i++)
        {
            for(int j = 0;j < n;j++)
            {
                if(matrix[i][j] == 0)
                {
                    dp[i][j] = 0;
                    continue;
                }
                if(i > 0)
                    dp[i][j] = std::min(dp[i-1][j] + 1,dp[i][j]);
                if(j > 0)
                    dp[i][j] = std::min(dp[i][j-1] + 1,dp[i][j]);     
            }
        }

        for(int i = m - 1;i >= 0;--i)
        {
            for(int j = n -1;j >= 0;--j)
            {
                if(matrix[i][j] == 0)
                {
                    dp[i][j] = 0;
                    continue;
                }
                if(i < m -1)
                    dp[i][j] = std::min(dp[i+1][j] + 1,dp[i][j]);
                if(j < n-1)
                    dp[i][j] = std::min(dp[i][j+1] + 1,dp[i][j]);               
            }
        }

        return dp;
    }
};
```

# 最大正方形

[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        int m = matrix.size(),n = matrix[0].size(),max_side = 0;
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i=1;i<=m;++i)
            for(int j=1;j<=n;++j){
                if(matrix[i-1][j-1] == '1')
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j])) + 1;
                 max_side = max(max_side,dp[i][j]);
            }         
        return max_side * max_side;
    }
};
```

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)