# 120 三角形最小路径和

[120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

状态转移自底向上进行，并且使用一维的 dp 记录每行的每个节点的最小值：

```
class Solution
{
public:
    int minimumTotal(vector<vector<int>> &triangle)
    {
        if (triangle.empty() || triangle[0].empty())
            return 0;
        int rows = triangle.size();
        vector<int> dp(triangle[rows-1].begin(),triangle[rows-1].end());

        for (int i = rows - 2; i >= 0; i--)
        {
            for (int j = 0; j < triangle[i].size(); j++)
            {
                dp[j] = min(dp[j],dp[j+1]) + triangle[i][j];
            }
        }
        return dp[0];
    }
};
```

- 时间复杂度：O(n^2)，n 是矩阵的行数
- 空间复杂度：O(n)，n 是矩阵的行数

# 不同路径I

[不同路径I](https://leetcode-cn.com/problems/unique-paths/)

```
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n,1);  //@ 存储每一行的结果

        for(int i = 1; i < m; ++i) 
            for(int j = 1; j < n; ++j) 
                dp[j] += dp[j-1];
        return dp.back();
    }
};
```

# 不同路径II

[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		if(obstacleGrid.empty() || obstacleGrid[0].empty())
			return 0;
		
		int m = obstacleGrid.size(),n = obstacleGrid[0].size();
        vector<int> dp(n,0);
		dp[0] = (obstacleGrid[0][0] == 0);
		
		for(int i=0;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(obstacleGrid[i][j] == 1)
				{
					dp[j] = 0;
					continue;
				}
					
				if(j-1 >= 0 && obstacleGrid[i][j-1] == 0)
					dp[j] += dp[j-1];
			}
		return dp.back();
    }
};
```

# 礼物的最大价值

[礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

```
class Solution {
public:
    int maxValue(vector<vector<int>>& grid) {
		if(grid.empty() || grid[0].empty())
			return 0;
		
		int m = grid.size(),n = grid[0].size();
		vector<int> dp(n,0);	
		dp[0] = grid[0][0];
		for(int j =1;j<n;++j)
			dp[j] = dp[j-1] + grid[0][j];
		
		for(int i=1;i<m;++i)
			for(int j=0;j<n;++j)
			{
				if(j == 0)
					dp[j] += grid[i][0];
				else
					dp[j] = max(dp[j],dp[j-1]) + grid[i][j];
            }
		return dp.back();
    }
    
};
```

# 01 矩阵

[ 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

题目涉及上下左右四个方向，两遍动态搜索，第一遍：从左上到右下，第二遍，从右下到左上。

```
class Solution {
public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 0));
        for (int i = 0; i < matrix.size(); ++i) {
            for (int j = 0; j < matrix[0].size(); ++j) {
                if (matrix[i][j] == 0) continue;
                int up = i == 0 ? 10001 : dp[i-1][j] + 1;
                int left = j == 0 ? 10001 : dp[i][j-1] + 1;
                dp[i][j] = min(up, left);
            }
        }
        for (int i = matrix.size()-1; i >= 0; --i) {
            for (int j = matrix[0].size()-1; j >= 0; --j) {
                if (matrix[i][j] == 0) continue;
                int down = i == matrix.size()-1 ? 10001 : dp[i+1][j] + 1;
                int right = j == matrix[0].size()-1 ? 10001 : dp[i][j+1] +1;
                dp[i][j] = min(dp[i][j], min(down, right));
            }
        }
        return dp;
    }
};
```

# 最大正方形

[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty() || matrix[0].empty())
            return 0;
        int m = matrix.size(),n = matrix[0].size(),max_side = 0;
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i=1;i<=m;++i)
            for(int j=1;j<=n;++j){
                if(matrix[i-1][j-1] == '1')
                    dp[i][j] = min(dp[i-1][j-1],min(dp[i][j-1],dp[i-1][j])) + 1;
                 max_side = max(max_side,dp[i][j]);
            }         
        return max_side * max_side;
    }
};
```

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)