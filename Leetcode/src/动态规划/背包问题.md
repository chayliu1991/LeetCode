# 背包问题

背包问题是一种组合优化的NP 完全问题：有N 个物品和容量为W的背包，每个物品都有自己的体积w 和价值v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择0 个或1 个，则问题称为0-1 背包问题；如果不限定每种物品的数量，则问题称为无界背包问题或完全背包问题。

## 0-1 背包

我们可以定义一个二维数组 dp 存储最大价值，其中 `dp[i][j] `表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，如果我们不将物品 i 放入背包，那么`dp[i][j]= dp[i-1][j]`，即前 i 个物品的最大价值等于只取前 i-1 个物品时的最大价值；如果我们将物品 i 放入背包，假设第 i 件物品体积为w，价值为v，那么我们得到 `p[i][j] = dp[i-1][j-w] + v`。我们只需在遍历过程中对这两种情况取最大值即可。

```
int knapsack(vector<int> weights, vector<int> values, int N, int W)
{
	vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
	for (int i = 1; i <= N; ++i)
	{
		int w = weights[i - 1], v = values[i - 1];
		for (int j = 1; j <= W; ++j) {
			if (j >= w) {
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v);
			}
			else {
				dp[i][j] = dp[i - 1][j];
			}
		}
	}
	return dp[N][W];
}
```

进一步可以进行空间压缩：

```
int knapsack(vector<int> weights, vector<int> values, int N, int W) {
	vector<int> dp(W + 1, 0);
	for (int i = 1; i <= N; ++i) 
	{
		int w = weights[i - 1], v = values[i - 1];
		for (int j = W; j >= w; --j) {
			dp[j] = max(dp[j], dp[j - w] + v);
		}
	}
	return dp[W];
}
```

## 完全背包

在完全背包问题中，一个物品可以拿多次。完全背包问题的状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)`，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。

```
int knapsack(vector<int> weights, vector<int> values, int N, int W) 
{
	vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
	for (int i = 1; i <= N; ++i) {
		int w = weights[i - 1], v = values[i - 1];
		for (int j = 1; j <= W; ++j) 
		{
			if (j >= w) {
				dp[i][j] = max(dp[i - 1][j], dp[i][j - w] + v);
			}
			else {
				dp[i][j] = dp[i - 1][j];
			}
		}
	}
	return dp[N][W];
}
```

状态空间压缩：

```
int knapsack(vector<int> weights, vector<int> values, int N, int W) 
{
	vector<int> dp(W + 1, 0);
	for (int i = 1; i <= N; ++i) 
	{
		int w = weights[i - 1], v = values[i - 1];
		for (int j = w; j <= W; ++j) {
			dp[j] = max(dp[j], dp[j - w] + v);
		}
	}
	return dp[W];
}
```

# 分割等和子集

[分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

本题可以等价于 0-1 背包问题，设所有数字的和为 sum，我们的目标是选出一部分使得他们的和为 sum/2。

```
class Solution {
public:
    bool canPartition(vector<int>& nums) {
		int sum  = accumulate(nums.begin(),nums.end(),0);
		if(sum % 2) return false; //@ 如果和是奇数，不可能平分
		int target = sum / 2,n = nums.size();
		vector<vector<bool>> dp(n+1,vector<bool>(target+1,false));
		
		for(int i=0;i<=n;++i)
			dp[i][0] = true;
		
		for(int i=1;i<=n;++i)
			for(int j=nums[i-1];j<=target;++j)
				dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
		
		return dp[n][target];
    }
};
```

也可以对本题进行空间压缩。注意对数字和的遍历需要逆向。 

```
class Solution {
public:
    bool canPartition(vector<int>& nums) {
		int sum  = accumulate(nums.begin(),nums.end(),0);
		if(sum % 2) return false; //@ 如果和是奇数，不可能平分
		int target = sum / 2,n = nums.size();
		vector<bool> dp(target+1,false));	
		dp[0] = true;
		
		for(int i=1;i<=n;++i)
			for(int j=target;j>=nums[i-1];--j)
				dp[j] = dp[j] || dp[j-nums[i-1]];
		
		return dp[target];
    }
};
```

# 一和零

[一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

这是一个多维费用的 0-1 背包问题，有两个背包大小， 0 的数量和 1 的数量。我们在这里直
接展示三维空间压缩到二维后的写法。

```
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
		vector<vector<int>> dp(m+1,vector<int>(n+1,0));
		for(const string & str : strs)
		{
			auto [count0,count1] = count(str);
			for(int i=m;i>=count0;--i)
				for(int j=n;j>=count1;--j)
					dp[i][j] = max(dp[i][j],1+dp[i-count0][j-count1]);
		}
		return dp[m][n];
    }
	
	//@ 辅助函数，统计0,1的数量
	pair<int,int> count(const string& s)
	{
		int count0 = s.length(),count1 = 0;
		for(const char &c : s)
		{
			if(c == '1')
			{
				++count1;
				--count0;
			}
		}
		return make_pair(count0,count1);
	}
};
```
# 零钱兑换

[零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if (coins.empty() || amount <= 0)
            return 0;

        int MAX =  INT_MAX -1; //@ 防止 INT_MAX + 1 溢出
        vector<int> dp(amount + 1, MAX);
        dp[0] = 0;
        for (int i = 1; i <= amount; ++i)    
            for(auto coin : coins)
            {
                if(coin <= i)
                    dp[i] = min(dp[i], dp[i -coin] + 1);
            }   
        return dp.back() == MAX ? -1 : dp.back();
    }
};
```

# 零钱兑换 II

[零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

```
class Solution {
public:
    int change(int amount, vector<int>& coins) {
     vector<int> dp(amount+1,0);
     dp[0] = 1;
     for(auto coin : coins)
         for(int i = coin;i<=amount;++i)
            dp[i] += dp[i-coin];
     
     return dp[amount];
    }
};
```