# [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

```
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        if(nums.empty() || nums[0].empty())
            return nums;
        
        int ori_rows = nums.size(),ori_cols = nums[0].size();
        if(ori_cols * ori_rows != r *c)
            return nums;
        vector<vector<int>>  res(r,vector<int>(c,0));
        for(int i = 0;i < ori_rows * ori_cols;i++)
            res[i / c][i % c] = nums[i / ori_cols][i % ori_cols];
        return res;
    }
};
```

#  [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

```
class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int,vector<int>> record;
        for(int i = 0;i < nums.size();i++)
            record[nums[i]].push_back(i);
        
        int degree = 0,length = 0;
        for(const auto r : record)
        {
            int deg = r.second.size();            
            if(deg >= degree)
            {
                int len = r.second.back() - r.second.front() + 1;
                if(deg > degree)
                {
                    degree = deg;
                    length = len;
                }
                else
                    length = min(len,length);
            }
        }
        return length;
    }
};
```

# [870. 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)

```
class Solution {
public:
    vector<int> advantageCount(vector<int>& A, vector<int>& B) {
        vector<pair<int,int>> record;
        for(int i = 0;i < B.size();i++)
            record.push_back({B[i],i});
        
        sort(record.begin(), record.end(), [](const pair<int, int>& a, const pair<int, int>& b) {return a.first < b.first;});
        sort(A.begin(),A.end());
        vector<int> res(A.size(),0);
        int j = 0;
        for(int i = 0;i < A.size();i++)
        {
            if(A[i] > record[j].first)
            {
                res[record[j].second] = A[i];
                j++;
            }
            else
            {
                //@ B 数组当前最大值的位置填上当前A的最小值
                res[record.back().second] = A[i];  
                record.pop_back();
            }
        }
        return res;
    }
};
```

# [26. 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int index = 0;
        for(const auto n : nums)
        {
            if(index == 0 || n > nums[index-1])
                nums[index++] = n;
        }
        return index;
    }
};
```

# [80. 删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int index = 0;
        for(int num : nums)
        {
            if(index <= 1 || num > nums[index-2])
            {
                nums[index] = num;
                index++;
            }
        }
        return index;
    }
};
```

# [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
		set<int> s(nums1.begin(),nums1.end()),res;
		for(const auto n : nums2)
		{
			if(s.count(n))
				res.insert(n);
		}
		return  vector<int>(res.begin(),res.end());
    }
};
```

STL：

```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
		set<int> s1(nums1.begin(),nums1.end()),s2(nums2.begin(),nums2.end()),res;
		set_intersection(s1.begin(),s1.end(),s2.begin(),s2.end(),inserter(res,res.begin()));
		return vector<int>(res.begin(),res.end());
    }
};
```

