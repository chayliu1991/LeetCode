# [670. 最大交换](https://leetcode-cn.com/problems/maximum-swap/)

```
class Solution {
public:
    int maximumSwap(int num) {
        if (num <= 10) return num;
        
        string s = to_string(num);
        int n = s.size();
        int q[n + 1], hh = 0, tt = -1;
        int f[n + 1]; // 表示每位之后，比该位大的数字最后出现的索引
        for (int i = n - 1; i >= 0; i --) {
            while (hh <= tt && s[q[tt]] < s[i]) tt --;  // 所有元素只会入队一次
            q[++ tt] = i;
            if (hh <= tt) f[i] = q[hh];
        }

        for (int i = 0; i < n; i ++) {
            if (s[i] != s[f[i]]) { // 如果该位的数字不是后面的最高位
                swap(s[i], s[f[i]]);
                break;
            }
        }
        return atoi(s.c_str());
    }
};
```

