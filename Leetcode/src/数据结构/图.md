# 785. 判断二分图

[785. 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

BFS：

```
class Solution {
public:
    bool isBipartite(vector<vector<int>>& graph) {
		int n = graph.size(); //@ 有多少个节点
		if(n == 0)
			return true;
		
		//@ -1 表示节点还没有染色，0 表示染成一种颜色，1表示染成另一种颜色
		vector<int> color(n,-1);
		for(int i = 0;i < n;++i) //@ 遍历所有节点
		{			
			if(color[i] == -1)  //@ 该节点尚未被染色
			{
				queue<int> q;
				q.push(i);
				color[i] = 0; //@ 染成某种颜色
				while(!q.empty())
				{
					int node = q.front();
					q.pop();
					//@ 相邻节点都应该是反色
					int c_neighbor = color[node] == 0 ? 1 : 0;
					for(const auto j : graph[node])
					{
						if(color[j] == -1) //@ 没有被染色
						{
							q.push(j);
							color[j] = c_neighbor;
						}
						else if(color[j] != c_neighbor) //@ 被染色过，但不是正确的颜色
							return false;
					}
				}
			}	
		}
		return true;
    }
};
```

DFS：

```
class Solution {
public:
	vector<int> color;
	bool dfs(vector<vector<int>>& graph,int i,int c)
	{
		if(color[i] != -1)
			return color[i] == c;
            
        color[i] = c;		
		for(int node : graph[i])
			if(!dfs(graph,node,!c))
				return false;
		return true;
 	}	
	
    bool isBipartite(vector<vector<int>>& graph) {
		int n = graph.size();
		if(n == 0)
			return true;
		
		color.assign(n,-1);
		for(int i =0;i< n;i++)
			if(color[i] == -1 && !dfs(graph,i,0))
				return false;
		return true;
    }
};
```

# 207. 课程表

[207. 课程表](https://leetcode-cn.com/problems/course-schedule/)







# 210. 课程表 II

[210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

