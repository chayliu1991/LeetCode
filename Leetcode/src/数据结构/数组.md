

# 重塑矩阵

[重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)

```
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& nums, int r, int c) {
        if(nums.empty() || nums[0].empty())
            return {};
        
        int R = nums.size();
        int C = nums[0].size();
        if(R*C != r*c)
            return nums;
        
        vector<vector<int>> res(r,vector<int>(c,0));
        for(int i = 0;i < R * C;++i)
            res[i/c][i%c] = nums[i/C][i%C];
        return res;
    }
};
```

# 数组的度

[数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

```
class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int,vector<int>> degree_dict;
        for(int i = 0;i < nums.size();++i)
            degree_dict[nums[i]].push_back(i);
        
        int nums_degree = 0,min_len = 0;
        for(const auto n : nums)
        {
            int tmp_degree = degree_dict[n].size();
            int tmp_len = degree_dict[n][tmp_degree-1] - degree_dict[n][0] + 1;
            if(tmp_degree >= nums_degree)
            {
                if(tmp_degree == nums_degree)
                    min_len = min(min_len,tmp_len);
                else
                {
                    nums_degree = tmp_degree;
                    min_len = tmp_len;
                }
            }
        }
        return min_len;
    }
};
```

# 优势洗牌

[优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle/)  

```
class Solution {
public:
    vector<int> advantageCount(vector<int>& A, vector<int>& B) {
        vector<pair<int, int>> numIndex;
        for (int i = 0; i < B.size(); i++) 
            numIndex.push_back(make_pair(B[i], i));
        sort(numIndex.begin(), numIndex.end(), [](const pair<int, int>& a, const pair<int, int>& b) {
            return a.first < b.first;
        });
		
        sort(A.begin(), A.end());
        vector<int> res(A.size(), 0);
        int bIndex = 0;
        for (int i  = 0; i < A.size(); i++) 
		{
            if (A[i] > numIndex[bIndex].first) {
                res[numIndex[bIndex].second] = A[i];
                bIndex++;
            } else {
                res[numIndex.back().second] = A[i];
                numIndex.pop_back();
            }
        }
        return res;
    }
};
```

# 移除元素

[移除元素](https://leetcode-cn.com/problems/remove-element/)

使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不满足指定的值，slow指针前进一步，这样不满足条件的整数都被移动到数组的前面。

```
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int res = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != val) 
                nums[res++] = nums[i];
        }
        return res;
    }
};
```

# 移动零

[移动零](https://leetcode-cn.com/problems/move-zeroes/)

使用slow和fast两个指针，从头部开始遍历，遍历一次fast指针前进一步，当遍历元素不等于0，slow指针前进一步，这样不等于0的整数都被移动到数组的前面。

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0,fast = 0,n = nums.size();
        while(fast < n)
        {
            if(nums[fast] != 0)
                swap(nums[slow++],nums[fast]);
            fast++;
        }        
    }
};
```

# 删除排序数组中的重复项

[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第2个数字，如果快指针指向的数等于慢指针的前1个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 1, fast = 1, n = nums.size();
        if(n <= 1) return n;
        while(fast < n){
            if(nums[fast] != nums[slow - 1]) nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```

# 删除排序数组中的重复项 II

[删除排序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

使用快慢指针来记录遍历的坐标，最开始时两个指针都指向第3个数字，如果快指针指向的数等于慢指针的前2个数，则快指针向前走一步，如果不同，则两个指针都向前走一步，这样当快指针走完整个数组后，慢指针当前的坐标就是数组中不同数字的个数。

```
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slow = 2, fast = 2, n = nums.size();
        if(n <= 2) return n;
        while(fast < n){
            if(nums[fast] != nums[slow - 2]) 
                nums[slow++] = nums[fast];
            fast++;
        }
        return slow;
    }
};
```