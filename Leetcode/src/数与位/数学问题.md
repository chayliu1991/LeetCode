# 简单数学知识

辗转相除法：

```
int gcd(int a, int b)
{
	return b == 0 ? a : gcd(b, a % b);
}
```

最小公倍数：

```
int lcm(int a, int b)
{
	return  (a * b) / gcd(a, b);
}
```

质数：又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。 

# 204. 计数质数

[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)

除了2，其它偶数一定不是质数，只需要查看小于n的奇数中有多少是质数：

```
class Solution {
public:
    int countPrimes(int n) {
        int result = 0;
        vector<bool> prime(n,false);
        if(n > 2)
            result ++; //@ 如果大于2，则一定包含2这个质数
        for(int i = 3;i < n; i += 2) //@ 从 3 开始遍历，且只遍历奇数
        {
            if(prime[i] == false)
            {
                for(int j = 3;i * j < n;j += 2)
                    prime[i * j] = true; //@ 将当前质数的奇数倍都设置成非质数标记 true
                result ++;  //@ 质数个数 + 1
            }
        }
        return result;
    }
};
```

# 504. 七进制数

[504. 七进制数](https://leetcode-cn.com/problems/base-7/)

递归：

```
class Solution {
public:
    string convertToBase7(int num) {
        if(num < 0)
            return  "-" + convertToBase7(-num);
        if(num < 7)
            return to_string(num);
        return convertToBase7(num / 7) + to_string(num % 7);
    } 
};
```

非递归：

```
class Solution {
public:
    string convertToBase7(int num) {
        string res;
        int negative = num < 0;
        if(negative)
            num = -num;
        while(num / 7 != 0)
        {
            res = char(num % 7 + '0') + res;
            num /= 7;
        }
        res = char(num + '0') + res;
        return negative ? "-" + res : res;
    }
};
```

# 172. 阶乘后的零

[172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

每个尾部的 0 由 `2 * 5 = 10` 而来，因此可以把每一个元素拆分成质数相乘，统计有多少个 2 和 5。质因子 2 的数量远多于质因子 5 的数量，因此，可以统计阶乘结果里有多少个质因子 5：

```
class Solution {
public:
    int trailingZeroes(int n) {
        int count = 0;
        while(n >= 5)
        {
            count += n /5;
            n /= 5;
        }
        return count;
    }
};
```

递归：

```
class Solution {
public:
    int trailingZeroes(int n) {
        return n >= 5 ? n / 5 + trailingZeroes(n / 5) : 0; 
    }
};
```

# 415. 字符串相加

[415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

```
class Solution {
public:
    string addStrings(string num1, string num2) {
        int i = num1.size() - 1,j = num2.size() - 1;
        int add = 0;
        string res;
        while(i >= 0 || j >= 0 || add != 0)
        {
            int x = i >= 0 ? num1[i] - '0' : 0;
            int y = j >= 0 ? num2[j] - '0' : 0;
            int result = x + y + add;
            res.push_back('0' + result % 10);
            add = result / 10;
            i -= 1;
            j -= 1;
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

# 326. 3的幂

[326. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

```
class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n <= 0)
            return false;
        double d = log10(n) / log10(3);  //@ 换底
        return d == floor(d);   //@ 判断换底后的log3n是否为整数，即n是否为3的倍数
    }
};

class Solution {
public:
    bool isPowerOfThree(int n) {
        if(n < 1)
            return false;        
        while(n % 3 == 0)
            n /= 3;
        return n == 1;
    }
};
```


# 168. Excel表列名称

[168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

```
class Solution {
public:
    string convertToTitle(int n) {
		string str;
		while(n)
		{
			str += ((--n) % 26) + 'A'; //@ 先减去1是为了防止能够被26整除的数字，结果不是 'Z'
			n /= 26;	
		}
		return string(str.rbegin(),str.rend());
    }
};
```

# 169. 多数元素

[169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

排序：

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

Boyer-Moore 投票算法：

```
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```

# 67. 二进制求和

[67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

```
class Solution {
public:
    string addBinary(string a, string b) {
        string res;
		int m = a.length() - 1,n = b.length() - 1,carry = 0;		
		while (m >= 0 || n >= 0)
		{
			int p = m >= 0 ? a[m--] - '0' : 0;
			int q = n >= 0 ? b[n--] - '0' : 0;
			int sum = p + q + carry;
			res = to_string(sum % 2) + res;
			carry = sum / 2;
		}
        return carry == 1 ? '1' + res : res;
    }
};
```

# 238. 除自身以外数组的乘积

[238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)

左右乘积列表：

```
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
		vector<int>  leftproduct(nums.size(),1),rightproduct(nums.size(),1);
		for(int i = 1;i< nums.size();++i)
			leftproduct[i] = leftproduct[i-1] * nums[i-1];
		for(int i = nums.size() -2;i >= 0;--i)
			rightproduct[i] = rightproduct[i+1] * nums[i+1];
		vector<int> res(nums.size());
		for(int i =0;i< nums.size();++i)
			res[i] = rightproduct[i] * leftproduct[i];
		return res;
    }
};
```

空间压缩：

```
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> res(nums.size(), 1);
		for(int i = 1;i< nums.size();++i)
			res[i] = res[i-1] * nums[i-1];
		
		int R = 1;
		for(int i = nums.size() - 1;i >= 0;--i)
		{
			res[i] *= R;
			R *= nums[i]; 
		}		
		return res;
    }
};
```

# 462. 最少移动次数使数组元素相等 II

[462. 最少移动次数使数组元素相等 II](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/)

把数字调整相等的最小步数，一定是把大数变小，把小数变大，最后都达到其中位数：

```
class Solution {
public:
    int minMoves2(vector<int>& nums) {
		sort(nums.begin(),nums.end());
		int N = nums.size();
		int mid = nums[N/2];
		int res = 0;
		for(auto n : nums)
			res += abs(mid - n);
		return res;
    }
};
```

使用标准库函数：

```
class Solution {
public:
    int minMoves2(vector<int>& nums) {
		int N = nums.size();
		int mid = N / 2;
		nth_element(nums.begin(),nums.begin()+mid,nums.end());
		int res = 0;
		for(auto n : nums)
			res += abs(n - nums[mid]);
		return res;
    }
};
```

# 202. 快乐数

[202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

借助 `set` ：

```
class Solution {
public:
    bool isHappy(int n) {
        unordered_set<int> st;		
		while( n != 1)
		{
			int sum = 0;
			while(n)
			{
				sum += (n % 10) * (n % 10);
				n /= 10;
			}
			n = sum;
			if(st.count(n))
				break;
			st.insert(n);
		}
		return n == 1;
    }
};
```

快慢指针：

```
class Solution {
public:
    bool isHappy(int n) {
        int slow = n,fast = n;
		while(true)
		{			
			slow = next(slow);
			fast = next(fast);
			fast = next(fast);
			if(fast == slow)
				break;
		}		
		return slow == 1;
    }
	
	int next(int n)
	{
		int res = 0;
		while(n)
		{
			res += (n % 10) * (n % 10);
			n /= 10;
		}
		return res;
	}
};
```





