# 随机抽样算法

## 洗牌法

对于序列大小 `n` 已知的情况下，要求打乱后返回任一种排列都是等概率的。为凑成一个随机排列，每次产生随机的下标，把相应元素加到新序列中。

产生等概率的排列依赖于生成随机下标的随机算法 `rand()` 符合均匀分布。

```
void shuffle(vector<int>& nums)
{
	for(int i = nums.size()-1;i >= 0;i--)
	{
		int index = rand() % i + 1;
		swap(nums[i],nums[index]);
	}
}
```

## 蓄水池抽样

对于序列大小不确定或者不能一次性装入内存（比如数据流），要求随机获得一个元素，每个元素获取的概率都是相同的。这时遍历数据流中的每个元素，每次以 `1/i` 的概率保留当前元素（`i`是第几个元素），这时所有元素被取到的概率是相同的。

```
第1个元素：以1/1的概率保存nums[0]
第2个元素：以1/2的概率保存nums[1]，nums[0]被保存的概率为1 * 1/2 = 1/2
第3个元素：以1/3的概率保存nums[2]， 保存nums[0]或nums[1]的概率是2/3*1/2*1/1 = 1/3
```

```
int getRand(vector<int>& nums)
{
	int val = 0;
	for(int i = 0; i< nums.size();i++)
	{
		int index = rand% (i+1);
		if(index == 0)
			val = nums[i]  
	}
	return val;
}
```

如果想取得 `k` 个元素，那么每个元素被取到的概率为 `k/n`。先将前k个元素加入结果集，从 `k+1` 个元素开始，以 `k/i` 的概率保留当前元素到结果集，并随即替换结果集中的元素。

```
vector<int> getRandom(vector<int>& nums, int k)
{
    vector<int> res;
    for (int i = 0; i < k; i++) 
        res.push_back(nums[i]);

    for (int i = k; i < nums.size(); i++) 
    {
        int rd = rand() % (i + 1);
        if (rd < k) {
            int index = rand() % res.size();
            res[index] = nums[i];
        }
}
return res;
```

# [382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

```
class Solution {
	ListNode *head_;
public:
    Solution(ListNode* head) : head_(head){
    }
    int getRandom() {
        if(head_ == nullptr)
            return -1;
        int i = 1,res = head_->val;
        ListNode *cur = head_->next;
        while (cur) {
            if (rand() % ++i == 0) 
				res = cur->val;
            cur = cur->next;
        }
        return res;
    }   
};
```

# 328. 按权重随机选择

[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)

可以先使用 `partial_sum` 求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。这里的二分法可以用 `lower_bound` 实现。

```
class Solution {
    vector<int> _sums;
public:
    Solution(vector<int>& w) : _sums(std::move(w)){
        partial_sum(_sums.begin(),_sums.end(),_sums.begin());
    }
    
    int pickIndex() {
        int pos = (rand() % _sums.back()) + 1;
        return lower_bound(_sums.begin(),_sums.end(),pos) - _sums.begin();
    }
};
```

# 398. 随机数索引

[398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)

```
class Solution {
public:
    Solution(vector<int> nums): v(nums) {}
    
    int pick(int target) {
        int cnt = 0, res = -1;
        for (int i = 0; i < v.size(); ++i) {
            if (v[i] != target) 
				continue;
            ++cnt;
            if (rand() % cnt == 0) 
				res = i;
        }
        return res;
    }
private:
    vector<int> v;
};
```

# 470. 用 Rand7() 实现 Rand10()

[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

范围在 `1～7` 的随机数产生器，即 `1~7` 各个数字出现的概率皆为 `1/7`。范围在 `1～10` 的随机数产生器，即 `1~10` 各个数字出现的概率皆为 `1/10`。这个题的构造思路是先构造一个 `randN`，这个 `N` 必须是10的整数倍，然后 `randN % 10` 就可以得到了 `rand10`。所以可以从 `rand7` 先构造出 `rand49` ，再把 `rand49` 中大于等于 `40` 的都过滤掉，这样就得到了`rand40`，再对 `10` 取余即可。

```
class Solution {
public:
    int rand10() {
        while (true) {
            int num = (rand7() - 1) * 7 + rand7();
            if (num <= 40) 
                return num % 10 + 1;
        }
    }
};
```

递归：

```
class Solution {
public:
    int rand10() {
        int num = (rand7() - 1) * 7 + rand7();
        return (num <= 40) ? (num % 10 + 1) : rand10();
    }
};
```













